/* ConfigurationFile.c generated by valac 0.12.0, the Vala compiler
 * generated from ConfigurationFile.vala, do not modify */

/*SemesterLeistung - An IRC Daemon
* Copyright (C) 2011  Simon Baumer
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <stdlib.h>
#include <string.h>


#define DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE (daemon_configuration_configuration_file_get_type ())
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, DaemonConfigurationConfigurationFile))
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, DaemonConfigurationConfigurationFileClass))
#define DAEMON_CONFIGURATION_IS_CONFIGURATION_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE))
#define DAEMON_CONFIGURATION_IS_CONFIGURATION_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE))
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, DaemonConfigurationConfigurationFileClass))

typedef struct _DaemonConfigurationConfigurationFile DaemonConfigurationConfigurationFile;
typedef struct _DaemonConfigurationConfigurationFileClass DaemonConfigurationConfigurationFileClass;
typedef struct _DaemonConfigurationConfigurationFilePrivate DaemonConfigurationConfigurationFilePrivate;

#define DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION (daemon_configuration_server_configuration_get_type ())
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfiguration))
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfigurationClass))
#define DAEMON_CONFIGURATION_IS_SERVER_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION))
#define DAEMON_CONFIGURATION_IS_SERVER_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION))
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfigurationClass))

typedef struct _DaemonConfigurationServerConfiguration DaemonConfigurationServerConfiguration;
typedef struct _DaemonConfigurationServerConfigurationClass DaemonConfigurationServerConfigurationClass;

#define DAEMON_TYPE_SMTP_CONFIGURATION (daemon_smtp_configuration_get_type ())
#define DAEMON_SMTP_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfiguration))
#define DAEMON_SMTP_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfigurationClass))
#define DAEMON_IS_SMTP_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_TYPE_SMTP_CONFIGURATION))
#define DAEMON_IS_SMTP_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_TYPE_SMTP_CONFIGURATION))
#define DAEMON_SMTP_CONFIGURATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfigurationClass))

typedef struct _DaemonSmtpConfiguration DaemonSmtpConfiguration;
typedef struct _DaemonSmtpConfigurationClass DaemonSmtpConfigurationClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))

#define DAEMON_HELPERS_TYPE_LIST_HELPER (daemon_helpers_list_helper_get_type ())
#define DAEMON_HELPERS_LIST_HELPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_HELPERS_TYPE_LIST_HELPER, DaemonHelpersListHelper))
#define DAEMON_HELPERS_LIST_HELPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_HELPERS_TYPE_LIST_HELPER, DaemonHelpersListHelperClass))
#define DAEMON_HELPERS_IS_LIST_HELPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_HELPERS_TYPE_LIST_HELPER))
#define DAEMON_HELPERS_IS_LIST_HELPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_HELPERS_TYPE_LIST_HELPER))
#define DAEMON_HELPERS_LIST_HELPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_HELPERS_TYPE_LIST_HELPER, DaemonHelpersListHelperClass))

typedef struct _DaemonHelpersListHelper DaemonHelpersListHelper;
typedef struct _DaemonHelpersListHelperClass DaemonHelpersListHelperClass;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef enum  {
	DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid
} DaemonConfigurationConfigurationError;
#define DAEMON_CONFIGURATION_CONFIGURATION_ERROR daemon_configuration_configuration_error_quark ()
struct _DaemonConfigurationConfigurationFile {
	GObject parent_instance;
	DaemonConfigurationConfigurationFilePrivate * priv;
};

struct _DaemonConfigurationConfigurationFileClass {
	GObjectClass parent_class;
};

struct _DaemonConfigurationConfigurationFilePrivate {
	xmlDoc* _document;
	xmlNode* _root;
	gboolean _DisableDaemon;
	gchar* _LogLibrary;
	gchar* _LogFile;
	gchar** _Nicknames;
	gint _Nicknames_length1;
	gint __Nicknames_size_;
	gchar* _RealName;
	gchar* _Host;
	gchar* _Username;
	DaemonConfigurationServerConfiguration** _Servers;
	gint _Servers_length1;
	gint __Servers_size_;
	DaemonSmtpConfiguration* _Smtp;
};


static gpointer daemon_configuration_configuration_file_parent_class = NULL;

GQuark daemon_configuration_configuration_error_quark (void);
GType daemon_configuration_configuration_file_get_type (void) G_GNUC_CONST;
GType daemon_configuration_server_configuration_get_type (void) G_GNUC_CONST;
GType daemon_smtp_configuration_get_type (void) G_GNUC_CONST;
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, DaemonConfigurationConfigurationFilePrivate))
enum  {
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_DUMMY_PROPERTY,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_DISABLE_DAEMON,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_LIBRARY,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_FILE,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_NICKNAMES,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_REAL_NAME,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_HOST,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_USERNAME,
	DAEMON_CONFIGURATION_CONFIGURATION_FILE_SMTP
};
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE__stringFormat "Disable Daemon: %s\n" \
"Log Library: %s\n" \
"Log File: %s\n" \
"Nicknames: %s\n" \
"Servers:\n" \
"%s"
static void daemon_configuration_configuration_file_Parse (DaemonConfigurationConfigurationFile* self, GError** error);
static gchar* daemon_configuration_configuration_file_GetElementValue (DaemonConfigurationConfigurationFile* self, xmlNode* node, const gchar* elementName);
static void daemon_configuration_configuration_file_set_DisableDaemon (DaemonConfigurationConfigurationFile* self, gboolean value);
static void daemon_configuration_configuration_file_set_LogLibrary (DaemonConfigurationConfigurationFile* self, const gchar* value);
static void daemon_configuration_configuration_file_set_LogFile (DaemonConfigurationConfigurationFile* self, const gchar* value);
static void daemon_configuration_configuration_file_set_RealName (DaemonConfigurationConfigurationFile* self, const gchar* value);
static void daemon_configuration_configuration_file_set_Host (DaemonConfigurationConfigurationFile* self, const gchar* value);
static void daemon_configuration_configuration_file_set_Username (DaemonConfigurationConfigurationFile* self, const gchar* value);
static xmlNode* daemon_configuration_configuration_file_GetElement (DaemonConfigurationConfigurationFile* self, xmlNode* node, const gchar* elementName);
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
DaemonHelpersListHelper* daemon_helpers_list_helper_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func);
DaemonHelpersListHelper* daemon_helpers_list_helper_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func);
GType daemon_helpers_list_helper_get_type (void) G_GNUC_CONST;
gpointer* daemon_helpers_list_helper_CopyList (DaemonHelpersListHelper* self, GList* list, int* result_length1);
static void daemon_configuration_configuration_file_set_Nicknames (DaemonConfigurationConfigurationFile* self, gchar** value, int value_length1);
guint16* daemon_helpers_typehelper_ParsePort (const gchar* text);
DaemonSmtpConfiguration* daemon_smtp_configuration_new (const gchar* sender, const gchar* host, guint16 port);
DaemonSmtpConfiguration* daemon_smtp_configuration_construct (GType object_type, const gchar* sender, const gchar* host, guint16 port);
static void daemon_configuration_configuration_file_set_Smtp (DaemonConfigurationConfigurationFile* self, DaemonSmtpConfiguration* value);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static guint16* _uint16_dup (guint16* self);
DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_new (const gchar* host, guint16 port, gchar** channels, int channels_length1);
DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_construct (GType object_type, const gchar* host, guint16 port, gchar** channels, int channels_length1);
static void daemon_configuration_configuration_file_set_Servers (DaemonConfigurationConfigurationFile* self, DaemonConfigurationServerConfiguration** value, int value_length1);
static DaemonConfigurationConfigurationFile* daemon_configuration_configuration_file_new (const gchar* filename, GError** error);
static DaemonConfigurationConfigurationFile* daemon_configuration_configuration_file_construct (GType object_type, const gchar* filename, GError** error);
gchar* daemon_configuration_configuration_file_ToString (DaemonConfigurationConfigurationFile* self);
gboolean daemon_configuration_configuration_file_get_DisableDaemon (DaemonConfigurationConfigurationFile* self);
const gchar* daemon_configuration_configuration_file_get_LogLibrary (DaemonConfigurationConfigurationFile* self);
const gchar* daemon_configuration_configuration_file_get_LogFile (DaemonConfigurationConfigurationFile* self);
const gchar* daemon_configuration_configuration_file_get_RealName (DaemonConfigurationConfigurationFile* self);
const gchar* daemon_configuration_configuration_file_get_Host (DaemonConfigurationConfigurationFile* self);
const gchar* daemon_configuration_configuration_file_get_Username (DaemonConfigurationConfigurationFile* self);
DaemonSmtpConfiguration* daemon_configuration_configuration_file_get_Smtp (DaemonConfigurationConfigurationFile* self);
gchar* daemon_helpers_typehelper_IndentString (const gchar* text, gint count);
gchar* daemon_smtp_configuration_ToString (DaemonSmtpConfiguration* self);
gchar** daemon_configuration_configuration_file_get_Nicknames (DaemonConfigurationConfigurationFile* self, int* result_length1);
DaemonConfigurationServerConfiguration** daemon_configuration_configuration_file_get_Servers (DaemonConfigurationConfigurationFile* self, int* result_length1);
gchar* daemon_configuration_server_configuration_ToString (DaemonConfigurationServerConfiguration* self);
static void daemon_configuration_configuration_file_Release (DaemonConfigurationConfigurationFile* self);
DaemonConfigurationConfigurationFile* daemon_configuration_configuration_file_Load (const gchar* filename, GError** error);
static gchar** _vala_array_dup9 (gchar** self, int length);
static DaemonConfigurationServerConfiguration** _vala_array_dup10 (DaemonConfigurationServerConfiguration** self, int length);
static void daemon_configuration_configuration_file_finalize (GObject* obj);
static void _vala_daemon_configuration_configuration_file_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_daemon_configuration_configuration_file_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GQuark daemon_configuration_configuration_error_quark (void) {
	return g_quark_from_static_string ("daemon_configuration_configuration_error-quark");
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static guint16* _uint16_dup (guint16* self) {
	guint16* dup;
	dup = g_new0 (guint16, 1);
	memcpy (dup, self, sizeof (guint16));
	return dup;
}


static gpointer __uint16_dup0 (gpointer self) {
	return self ? _uint16_dup (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void daemon_configuration_configuration_file_Parse (DaemonConfigurationConfigurationFile* self, GError** error) {
	xmlNode* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	xmlNode* _tmp13_ = NULL;
	xmlNode* nicknamesNode;
	xmlNode* _tmp26_ = NULL;
	xmlNode* smtpNode;
	xmlNode* _tmp42_ = NULL;
	xmlNode* serversNode;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = xmlDocGetRootElement (self->priv->_document);
	self->priv->_root = _tmp0_;
	if (self->priv->_root == NULL) {
		return;
	}
	_tmp1_ = daemon_configuration_configuration_file_GetElementValue (self, self->priv->_root, "disable-daemon");
	_tmp2_ = _tmp1_;
	daemon_configuration_configuration_file_set_DisableDaemon (self, g_strcmp0 (_tmp2_, "true") == 0);
	_g_free0 (_tmp2_);
	_tmp3_ = daemon_configuration_configuration_file_GetElementValue (self, self->priv->_root, "log-library");
	_tmp4_ = _tmp3_;
	daemon_configuration_configuration_file_set_LogLibrary (self, _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = daemon_configuration_configuration_file_GetElementValue (self, self->priv->_root, "log-file");
	_tmp6_ = _tmp5_;
	daemon_configuration_configuration_file_set_LogFile (self, _tmp6_);
	_g_free0 (_tmp6_);
	_tmp7_ = daemon_configuration_configuration_file_GetElementValue (self, self->priv->_root, "realname");
	_tmp8_ = _tmp7_;
	daemon_configuration_configuration_file_set_RealName (self, _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = daemon_configuration_configuration_file_GetElementValue (self, self->priv->_root, "hostname");
	_tmp10_ = _tmp9_;
	daemon_configuration_configuration_file_set_Host (self, _tmp10_);
	_g_free0 (_tmp10_);
	_tmp11_ = daemon_configuration_configuration_file_GetElementValue (self, self->priv->_root, "username");
	_tmp12_ = _tmp11_;
	daemon_configuration_configuration_file_set_Username (self, _tmp12_);
	_g_free0 (_tmp12_);
	_tmp13_ = daemon_configuration_configuration_file_GetElement (self, self->priv->_root, "nicknames");
	nicknamesNode = _tmp13_;
	if (nicknamesNode != NULL) {
		GList* nicknames;
		DaemonHelpersListHelper* _tmp21_ = NULL;
		DaemonHelpersListHelper* helper;
		gint _tmp22_;
		gpointer* _tmp23_ = NULL;
		gchar** _tmp24_;
		gint _tmp24__length1;
		gchar** _tmp25_;
		nicknames = NULL;
		{
			xmlNode* iter;
			iter = nicknamesNode->children;
			{
				gboolean _tmp14_;
				_tmp14_ = TRUE;
				while (TRUE) {
					gchar* _tmp15_ = NULL;
					gchar* nickname;
					gboolean _tmp17_ = FALSE;
					gchar* _tmp20_;
					if (!_tmp14_) {
						iter = iter->next;
					}
					_tmp14_ = FALSE;
					if (!(iter != NULL)) {
						break;
					}
					if (iter->type != XML_ELEMENT_NODE) {
						continue;
					}
					_tmp15_ = xmlNodeGetContent (iter);
					nickname = _tmp15_;
					if (nickname != NULL) {
						gchar* _tmp16_ = NULL;
						_tmp16_ = string_strip (nickname);
						_g_free0 (nickname);
						nickname = _tmp16_;
					}
					if (nickname == NULL) {
						_tmp17_ = TRUE;
					} else {
						gint _tmp18_;
						_tmp18_ = strlen (nickname);
						_tmp17_ = _tmp18_ == 0;
					}
					if (_tmp17_) {
						GError* _tmp19_ = NULL;
						_tmp19_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Empty Nickname found");
						_inner_error_ = _tmp19_;
						if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (nickname);
							__g_list_free__g_free0_0 (nicknames);
							return;
						} else {
							_g_free0 (nickname);
							__g_list_free__g_free0_0 (nicknames);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					_tmp20_ = g_strdup (nickname);
					nicknames = g_list_append (nicknames, _tmp20_);
					_g_free0 (nickname);
				}
			}
		}
		_tmp21_ = daemon_helpers_list_helper_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free);
		helper = _tmp21_;
		_tmp23_ = daemon_helpers_list_helper_CopyList (helper, nicknames, &_tmp22_);
		_tmp24_ = _tmp23_;
		_tmp24__length1 = _tmp22_;
		_tmp25_ = _tmp24_;
		daemon_configuration_configuration_file_set_Nicknames (self, _tmp25_, _tmp22_);
		_tmp24_ = (_vala_array_free (_tmp24_, _tmp24__length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (helper);
		__g_list_free__g_free0_0 (nicknames);
	}
	_tmp26_ = daemon_configuration_configuration_file_GetElement (self, self->priv->_root, "smtp");
	smtpNode = _tmp26_;
	if (smtpNode != NULL) {
		gchar* _tmp27_ = NULL;
		gchar* sender;
		gchar* _tmp28_ = NULL;
		gchar* host;
		gchar* _tmp29_ = NULL;
		gchar* port;
		guint16* actualPort;
		gboolean _tmp30_ = FALSE;
		gboolean _tmp34_ = FALSE;
		DaemonSmtpConfiguration* _tmp40_ = NULL;
		DaemonSmtpConfiguration* _tmp41_;
		_tmp27_ = daemon_configuration_configuration_file_GetElementValue (self, smtpNode, "sender");
		sender = _tmp27_;
		_tmp28_ = daemon_configuration_configuration_file_GetElementValue (self, smtpNode, "host");
		host = _tmp28_;
		_tmp29_ = daemon_configuration_configuration_file_GetElementValue (self, smtpNode, "port");
		port = _tmp29_;
		actualPort = NULL;
		if (host == NULL) {
			_tmp30_ = TRUE;
		} else {
			gchar* _tmp31_ = NULL;
			gint _tmp32_;
			_tmp31_ = string_strip (host);
			_g_free0 (host);
			host = _tmp31_;
			_tmp32_ = strlen (host);
			_tmp30_ = _tmp32_ == 0;
		}
		if (_tmp30_) {
			GError* _tmp33_ = NULL;
			_tmp33_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Host required for SMTP");
			_inner_error_ = _tmp33_;
			if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (actualPort);
				_g_free0 (port);
				_g_free0 (host);
				_g_free0 (sender);
				return;
			} else {
				_g_free0 (actualPort);
				_g_free0 (port);
				_g_free0 (host);
				_g_free0 (sender);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		if (sender == NULL) {
			_tmp34_ = TRUE;
		} else {
			gchar* _tmp35_ = NULL;
			gint _tmp36_;
			_tmp35_ = string_strip (sender);
			_g_free0 (sender);
			sender = _tmp35_;
			_tmp36_ = strlen (sender);
			_tmp34_ = _tmp36_ == 0;
		}
		if (_tmp34_) {
			GError* _tmp37_ = NULL;
			_tmp37_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Sender required for SMTP");
			_inner_error_ = _tmp37_;
			if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (actualPort);
				_g_free0 (port);
				_g_free0 (host);
				_g_free0 (sender);
				return;
			} else {
				_g_free0 (actualPort);
				_g_free0 (port);
				_g_free0 (host);
				_g_free0 (sender);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		if (port != NULL) {
			guint16* _tmp38_ = NULL;
			_tmp38_ = daemon_helpers_typehelper_ParsePort (port);
			_g_free0 (actualPort);
			actualPort = _tmp38_;
			if (actualPort == NULL) {
				GError* _tmp39_ = NULL;
				_tmp39_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Could not parse port");
				_inner_error_ = _tmp39_;
				if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (actualPort);
					_g_free0 (port);
					_g_free0 (host);
					_g_free0 (sender);
					return;
				} else {
					_g_free0 (actualPort);
					_g_free0 (port);
					_g_free0 (host);
					_g_free0 (sender);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
		_tmp40_ = daemon_smtp_configuration_new (sender, host, *actualPort);
		_tmp41_ = _tmp40_;
		daemon_configuration_configuration_file_set_Smtp (self, _tmp41_);
		_g_object_unref0 (_tmp41_);
		_g_free0 (actualPort);
		_g_free0 (port);
		_g_free0 (host);
		_g_free0 (sender);
	}
	_tmp42_ = daemon_configuration_configuration_file_GetElement (self, self->priv->_root, "servers");
	serversNode = _tmp42_;
	if (serversNode != NULL) {
		GList* servers;
		DaemonHelpersListHelper* _tmp68_ = NULL;
		DaemonHelpersListHelper* serverHelper;
		gint _tmp69_;
		gpointer* _tmp70_ = NULL;
		DaemonConfigurationServerConfiguration** _tmp71_;
		gint _tmp71__length1;
		DaemonConfigurationServerConfiguration** _tmp72_;
		servers = NULL;
		{
			xmlNode* iter;
			iter = serversNode->children;
			{
				gboolean _tmp43_;
				_tmp43_ = TRUE;
				while (TRUE) {
					gchar* _tmp44_ = NULL;
					gchar* host;
					gchar* _tmp45_ = NULL;
					gchar* port;
					gboolean _tmp47_ = FALSE;
					guint16* _tmp50_ = NULL;
					guint16* _tmp51_;
					guint16 actualPort;
					GList* channels;
					xmlNode* _tmp54_ = NULL;
					xmlNode* channelsNode;
					DaemonHelpersListHelper* _tmp63_ = NULL;
					DaemonHelpersListHelper* helper;
					gint _tmp64_;
					gpointer* _tmp65_ = NULL;
					gchar** channelArray;
					gint channelArray_length1;
					gint _channelArray_size_;
					DaemonConfigurationServerConfiguration* _tmp66_ = NULL;
					DaemonConfigurationServerConfiguration* configuration;
					DaemonConfigurationServerConfiguration* _tmp67_;
					if (!_tmp43_) {
						iter = iter->next;
					}
					_tmp43_ = FALSE;
					if (!(iter != NULL)) {
						break;
					}
					if (iter->type != XML_ELEMENT_NODE) {
						continue;
					}
					_tmp44_ = daemon_configuration_configuration_file_GetElementValue (self, iter, "host");
					host = _tmp44_;
					_tmp45_ = daemon_configuration_configuration_file_GetElementValue (self, iter, "port");
					port = _tmp45_;
					if (host != NULL) {
						gchar* _tmp46_ = NULL;
						_tmp46_ = string_strip (host);
						_g_free0 (host);
						host = _tmp46_;
					}
					if (host == NULL) {
						_tmp47_ = TRUE;
					} else {
						gint _tmp48_;
						_tmp48_ = strlen (host);
						_tmp47_ = _tmp48_ == 0;
					}
					if (_tmp47_) {
						GError* _tmp49_ = NULL;
						_tmp49_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "No hostname defined for server");
						_inner_error_ = _tmp49_;
						if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (port);
							_g_free0 (host);
							__g_list_free__g_object_unref0_0 (servers);
							return;
						} else {
							_g_free0 (port);
							_g_free0 (host);
							__g_list_free__g_object_unref0_0 (servers);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					_tmp50_ = daemon_helpers_typehelper_ParsePort (port);
					_tmp51_ = _tmp50_;
					if (_tmp51_ == NULL) {
						gint _tmp52_;
						guint16* _tmp53_;
						_tmp52_ = 6667;
						_tmp53_ = __uint16_dup0 (&_tmp52_);
						_g_free0 (_tmp51_);
						_tmp51_ = _tmp53_;
					}
					actualPort = *_tmp51_;
					channels = NULL;
					_tmp54_ = daemon_configuration_configuration_file_GetElement (self, iter, "channels");
					channelsNode = _tmp54_;
					if (channelsNode == NULL) {
						GError* _tmp55_ = NULL;
						_tmp55_ = g_error_new (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "No channels defined for Server '%s:%s'", host, port);
						_inner_error_ = _tmp55_;
						if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
							g_propagate_error (error, _inner_error_);
							__g_list_free__g_free0_0 (channels);
							_g_free0 (_tmp51_);
							_g_free0 (port);
							_g_free0 (host);
							__g_list_free__g_object_unref0_0 (servers);
							return;
						} else {
							__g_list_free__g_free0_0 (channels);
							_g_free0 (_tmp51_);
							_g_free0 (port);
							_g_free0 (host);
							__g_list_free__g_object_unref0_0 (servers);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					{
						xmlNode* channelsIter;
						channelsIter = channelsNode->children;
						{
							gboolean _tmp56_;
							_tmp56_ = TRUE;
							while (TRUE) {
								gchar* _tmp57_ = NULL;
								gchar* channelName;
								gboolean _tmp59_ = FALSE;
								gchar* _tmp62_;
								if (!_tmp56_) {
									channelsIter = channelsIter->next;
								}
								_tmp56_ = FALSE;
								if (!(channelsIter != NULL)) {
									break;
								}
								if (channelsIter->type != XML_ELEMENT_NODE) {
									continue;
								}
								_tmp57_ = xmlNodeGetContent (channelsIter);
								channelName = _tmp57_;
								if (channelName != NULL) {
									gchar* _tmp58_ = NULL;
									_tmp58_ = string_strip (channelName);
									_g_free0 (channelName);
									channelName = _tmp58_;
								}
								if (channelName == NULL) {
									_tmp59_ = TRUE;
								} else {
									gint _tmp60_;
									_tmp60_ = strlen (channelName);
									_tmp59_ = _tmp60_ == 0;
								}
								if (_tmp59_) {
									GError* _tmp61_ = NULL;
									_tmp61_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Empty Channel Name found");
									_inner_error_ = _tmp61_;
									if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
										g_propagate_error (error, _inner_error_);
										_g_free0 (channelName);
										__g_list_free__g_free0_0 (channels);
										_g_free0 (_tmp51_);
										_g_free0 (port);
										_g_free0 (host);
										__g_list_free__g_object_unref0_0 (servers);
										return;
									} else {
										_g_free0 (channelName);
										__g_list_free__g_free0_0 (channels);
										_g_free0 (_tmp51_);
										_g_free0 (port);
										_g_free0 (host);
										__g_list_free__g_object_unref0_0 (servers);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return;
									}
								}
								_tmp62_ = g_strdup (channelName);
								channels = g_list_append (channels, _tmp62_);
								_g_free0 (channelName);
							}
						}
					}
					_tmp63_ = daemon_helpers_list_helper_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free);
					helper = _tmp63_;
					_tmp65_ = daemon_helpers_list_helper_CopyList (helper, channels, &_tmp64_);
					channelArray = _tmp65_;
					channelArray_length1 = _tmp64_;
					_channelArray_size_ = _tmp64_;
					_tmp66_ = daemon_configuration_server_configuration_new (host, actualPort, channelArray, channelArray_length1);
					configuration = _tmp66_;
					_tmp67_ = _g_object_ref0 (configuration);
					servers = g_list_append (servers, _tmp67_);
					_g_object_unref0 (configuration);
					channelArray = (_vala_array_free (channelArray, channelArray_length1, (GDestroyNotify) g_free), NULL);
					_g_object_unref0 (helper);
					__g_list_free__g_free0_0 (channels);
					_g_free0 (_tmp51_);
					_g_free0 (port);
					_g_free0 (host);
				}
			}
		}
		_tmp68_ = daemon_helpers_list_helper_new (DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, (GBoxedCopyFunc) g_object_ref, g_object_unref);
		serverHelper = _tmp68_;
		_tmp70_ = daemon_helpers_list_helper_CopyList (serverHelper, servers, &_tmp69_);
		_tmp71_ = _tmp70_;
		_tmp71__length1 = _tmp69_;
		_tmp72_ = _tmp71_;
		daemon_configuration_configuration_file_set_Servers (self, _tmp72_, _tmp69_);
		_tmp71_ = (_vala_array_free (_tmp71_, _tmp71__length1, (GDestroyNotify) g_object_unref), NULL);
		_g_object_unref0 (serverHelper);
		__g_list_free__g_object_unref0_0 (servers);
	}
}


static DaemonConfigurationConfigurationFile* daemon_configuration_configuration_file_construct (GType object_type, const gchar* filename, GError** error) {
	DaemonConfigurationConfigurationFile * self = NULL;
	xmlDoc* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (DaemonConfigurationConfigurationFile*) g_object_new (object_type, NULL);
	_tmp0_ = xmlParseFile (filename);
	self->priv->_document = _tmp0_;
	if (self->priv->_document == NULL) {
		GError* _tmp1_ = NULL;
		_tmp1_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Configuration file could not be opened");
		_inner_error_ = _tmp1_;
		if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	return self;
}


static DaemonConfigurationConfigurationFile* daemon_configuration_configuration_file_new (const gchar* filename, GError** error) {
	return daemon_configuration_configuration_file_construct (DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, filename, error);
}


gchar* daemon_configuration_configuration_file_ToString (DaemonConfigurationConfigurationFile* self) {
	gchar* result = NULL;
	GString* _tmp0_ = NULL;
	GString* builder;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp6_ = FALSE;
	gchar** _tmp7_ = NULL;
	gint _tmp8_;
	gboolean _tmp18_ = FALSE;
	DaemonConfigurationServerConfiguration** _tmp19_ = NULL;
	gint _tmp20_;
	gchar* _tmp34_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	g_string_append (builder, "{\n\t");
	g_string_append (builder, "Disable Daemon: ");
	if (self->priv->_DisableDaemon) {
		_tmp1_ = "true";
	} else {
		_tmp1_ = "false";
	}
	g_string_append (builder, _tmp1_);
	if (self->priv->_LogLibrary != NULL) {
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Log Library: ");
		g_string_append (builder, self->priv->_LogLibrary);
	}
	if (self->priv->_LogFile != NULL) {
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Log File: ");
		g_string_append (builder, self->priv->_LogFile);
	}
	if (self->priv->_RealName != NULL) {
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Real Name: ");
		g_string_append (builder, self->priv->_RealName);
	}
	if (self->priv->_Host != NULL) {
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Host: ");
		g_string_append (builder, self->priv->_Host);
	}
	if (self->priv->_Username != NULL) {
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Username: ");
		g_string_append (builder, self->priv->_Username);
	}
	if (self->priv->_Smtp != NULL) {
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Smtp Configuration:\n");
		_tmp2_ = daemon_smtp_configuration_ToString (self->priv->_Smtp);
		_tmp3_ = _tmp2_;
		_tmp4_ = daemon_helpers_typehelper_IndentString (_tmp3_, 1);
		_tmp5_ = _tmp4_;
		g_string_append (builder, _tmp5_);
		_g_free0 (_tmp5_);
		_g_free0 (_tmp3_);
	}
	_tmp7_ = daemon_configuration_configuration_file_get_Nicknames (self, &_tmp8_);
	if (_tmp7_ != NULL) {
		gchar** _tmp9_ = NULL;
		gint _tmp10_;
		_tmp9_ = daemon_configuration_configuration_file_get_Nicknames (self, &_tmp10_);
		_tmp6_ = _tmp10_ > 0;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Nicknames: ");
		g_string_append (builder, "\n\t[\n\t\t");
		{
			gint i;
			i = 0;
			{
				gboolean _tmp11_;
				_tmp11_ = TRUE;
				while (TRUE) {
					gchar** _tmp12_ = NULL;
					gint _tmp13_;
					gchar** _tmp14_ = NULL;
					gint _tmp15_;
					gchar** _tmp16_ = NULL;
					gint _tmp17_;
					if (!_tmp11_) {
						i++;
					}
					_tmp11_ = FALSE;
					_tmp12_ = daemon_configuration_configuration_file_get_Nicknames (self, &_tmp13_);
					if (!(i < _tmp13_)) {
						break;
					}
					_tmp14_ = daemon_configuration_configuration_file_get_Nicknames (self, &_tmp15_);
					g_string_append (builder, _tmp14_[i]);
					_tmp16_ = daemon_configuration_configuration_file_get_Nicknames (self, &_tmp17_);
					if (i < (_tmp17_ - 1)) {
						g_string_append (builder, ",\n\t\t");
					}
				}
			}
		}
		g_string_append (builder, "\n\t]");
	}
	_tmp19_ = daemon_configuration_configuration_file_get_Servers (self, &_tmp20_);
	if (_tmp19_ != NULL) {
		DaemonConfigurationServerConfiguration** _tmp21_ = NULL;
		gint _tmp22_;
		_tmp21_ = daemon_configuration_configuration_file_get_Servers (self, &_tmp22_);
		_tmp18_ = _tmp22_ > 0;
	} else {
		_tmp18_ = FALSE;
	}
	if (_tmp18_) {
		g_string_append (builder, ",\n\t");
		g_string_append (builder, "Servers: ");
		g_string_append (builder, "\n\t[\n");
		{
			gint i;
			i = 0;
			{
				gboolean _tmp23_;
				_tmp23_ = TRUE;
				while (TRUE) {
					DaemonConfigurationServerConfiguration** _tmp24_ = NULL;
					gint _tmp25_;
					DaemonConfigurationServerConfiguration** _tmp26_ = NULL;
					gint _tmp27_;
					gchar* _tmp28_ = NULL;
					gchar* _tmp29_;
					gchar* _tmp30_ = NULL;
					gchar* _tmp31_;
					DaemonConfigurationServerConfiguration** _tmp32_ = NULL;
					gint _tmp33_;
					if (!_tmp23_) {
						i++;
					}
					_tmp23_ = FALSE;
					_tmp24_ = daemon_configuration_configuration_file_get_Servers (self, &_tmp25_);
					if (!(i < _tmp25_)) {
						break;
					}
					_tmp26_ = daemon_configuration_configuration_file_get_Servers (self, &_tmp27_);
					_tmp28_ = daemon_configuration_server_configuration_ToString (_tmp26_[i]);
					_tmp29_ = _tmp28_;
					_tmp30_ = daemon_helpers_typehelper_IndentString (_tmp29_, 2);
					_tmp31_ = _tmp30_;
					g_string_append (builder, _tmp31_);
					_g_free0 (_tmp31_);
					_g_free0 (_tmp29_);
					_tmp32_ = daemon_configuration_configuration_file_get_Servers (self, &_tmp33_);
					if (i < (_tmp33_ - 1)) {
						g_string_append (builder, ",\n");
					}
				}
			}
		}
		g_string_append (builder, "\n\t]");
	}
	_tmp34_ = g_strdup (builder->str);
	result = _tmp34_;
	_g_string_free0 (builder);
	return result;
}


static xmlNode* daemon_configuration_configuration_file_GetElement (DaemonConfigurationConfigurationFile* self, xmlNode* node, const gchar* elementName) {
	xmlNode* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (elementName != NULL, NULL);
	{
		xmlNode* iter;
		iter = node->children;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					iter = iter->next;
				}
				_tmp0_ = FALSE;
				if (!(iter != NULL)) {
					break;
				}
				if (iter->type != XML_ELEMENT_NODE) {
					continue;
				}
				if (g_strcmp0 (iter->name, elementName) == 0) {
					result = iter;
					return result;
				}
			}
		}
	}
	result = NULL;
	return result;
}


static gchar* daemon_configuration_configuration_file_GetElementValue (DaemonConfigurationConfigurationFile* self, xmlNode* node, const gchar* elementName) {
	gchar* result = NULL;
	xmlNode* _tmp0_ = NULL;
	xmlNode* elementNode;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (elementName != NULL, NULL);
	_tmp0_ = daemon_configuration_configuration_file_GetElement (self, node, elementName);
	elementNode = _tmp0_;
	if (elementNode == NULL) {
		result = NULL;
		return result;
	}
	_tmp1_ = xmlNodeGetContent (elementNode);
	result = _tmp1_;
	return result;
}


static void daemon_configuration_configuration_file_Release (DaemonConfigurationConfigurationFile* self) {
	g_return_if_fail (self != NULL);
	xmlFreeDoc (self->priv->_document);
}


static gpointer _g_error_copy0 (gpointer self) {
	return self ? g_error_copy (self) : NULL;
}


DaemonConfigurationConfigurationFile* daemon_configuration_configuration_file_Load (const gchar* filename, GError** error) {
	DaemonConfigurationConfigurationFile* result = NULL;
	DaemonConfigurationConfigurationFile* file;
	DaemonConfigurationConfigurationFile* _tmp0_ = NULL;
	DaemonConfigurationConfigurationFile* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	file = NULL;
	_tmp0_ = daemon_configuration_configuration_file_new (filename, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
			goto __catch28_daemon_configuration_configuration_error;
		}
		if (file != NULL) {
			daemon_configuration_configuration_file_Release (file);
		}
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_g_object_unref0 (file);
	file = _tmp1_;
	daemon_configuration_configuration_file_Parse (file, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
			goto __catch28_daemon_configuration_configuration_error;
		}
		if (file != NULL) {
			daemon_configuration_configuration_file_Release (file);
		}
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	goto __finally28;
	__catch28_daemon_configuration_configuration_error:
	{
		GError * _error_;
		GError* _tmp2_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = _g_error_copy0 (_error_);
		_inner_error_ = _tmp2_;
		_g_error_free0 (_error_);
		goto __finally28;
	}
	__finally28:
	if (file != NULL) {
		daemon_configuration_configuration_file_Release (file);
	}
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (file);
			return NULL;
		} else {
			_g_object_unref0 (file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = file;
	return result;
}


gboolean daemon_configuration_configuration_file_get_DisableDaemon (DaemonConfigurationConfigurationFile* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_DisableDaemon;
	return result;
}


static void daemon_configuration_configuration_file_set_DisableDaemon (DaemonConfigurationConfigurationFile* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_DisableDaemon = value;
	g_object_notify ((GObject *) self, "DisableDaemon");
}


const gchar* daemon_configuration_configuration_file_get_LogLibrary (DaemonConfigurationConfigurationFile* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_LogLibrary;
	return result;
}


static void daemon_configuration_configuration_file_set_LogLibrary (DaemonConfigurationConfigurationFile* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_LogLibrary);
	self->priv->_LogLibrary = _tmp0_;
	g_object_notify ((GObject *) self, "LogLibrary");
}


const gchar* daemon_configuration_configuration_file_get_LogFile (DaemonConfigurationConfigurationFile* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_LogFile;
	return result;
}


static void daemon_configuration_configuration_file_set_LogFile (DaemonConfigurationConfigurationFile* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_LogFile);
	self->priv->_LogFile = _tmp0_;
	g_object_notify ((GObject *) self, "LogFile");
}


gchar** daemon_configuration_configuration_file_get_Nicknames (DaemonConfigurationConfigurationFile* self, int* result_length1) {
	gchar** result;
	gchar** _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_Nicknames;
	*result_length1 = self->priv->_Nicknames_length1;
	result = _tmp0_;
	return result;
}


static gchar** _vala_array_dup9 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static void daemon_configuration_configuration_file_set_Nicknames (DaemonConfigurationConfigurationFile* self, gchar** value, int value_length1) {
	gchar** _tmp0_;
	gchar** _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (_tmp1_ = value, (_tmp1_ == NULL) ? ((gpointer) _tmp1_) : _vala_array_dup9 (_tmp1_, value_length1));
	self->priv->_Nicknames = (_vala_array_free (self->priv->_Nicknames, self->priv->_Nicknames_length1, (GDestroyNotify) g_free), NULL);
	self->priv->_Nicknames = _tmp0_;
	self->priv->_Nicknames_length1 = value_length1;
	self->priv->__Nicknames_size_ = value_length1;
	g_object_notify ((GObject *) self, "Nicknames");
}


const gchar* daemon_configuration_configuration_file_get_RealName (DaemonConfigurationConfigurationFile* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_RealName;
	return result;
}


static void daemon_configuration_configuration_file_set_RealName (DaemonConfigurationConfigurationFile* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_RealName);
	self->priv->_RealName = _tmp0_;
	g_object_notify ((GObject *) self, "RealName");
}


const gchar* daemon_configuration_configuration_file_get_Host (DaemonConfigurationConfigurationFile* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Host;
	return result;
}


static void daemon_configuration_configuration_file_set_Host (DaemonConfigurationConfigurationFile* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Host);
	self->priv->_Host = _tmp0_;
	g_object_notify ((GObject *) self, "Host");
}


const gchar* daemon_configuration_configuration_file_get_Username (DaemonConfigurationConfigurationFile* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Username;
	return result;
}


static void daemon_configuration_configuration_file_set_Username (DaemonConfigurationConfigurationFile* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Username);
	self->priv->_Username = _tmp0_;
	g_object_notify ((GObject *) self, "Username");
}


DaemonConfigurationServerConfiguration** daemon_configuration_configuration_file_get_Servers (DaemonConfigurationConfigurationFile* self, int* result_length1) {
	DaemonConfigurationServerConfiguration** result;
	DaemonConfigurationServerConfiguration** _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_Servers;
	*result_length1 = self->priv->_Servers_length1;
	result = _tmp0_;
	return result;
}


static DaemonConfigurationServerConfiguration** _vala_array_dup10 (DaemonConfigurationServerConfiguration** self, int length) {
	DaemonConfigurationServerConfiguration** result;
	int i;
	result = g_new0 (DaemonConfigurationServerConfiguration*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = _g_object_ref0 (self[i]);
	}
	return result;
}


static void daemon_configuration_configuration_file_set_Servers (DaemonConfigurationConfigurationFile* self, DaemonConfigurationServerConfiguration** value, int value_length1) {
	DaemonConfigurationServerConfiguration** _tmp0_;
	DaemonConfigurationServerConfiguration** _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (_tmp1_ = value, (_tmp1_ == NULL) ? ((gpointer) _tmp1_) : _vala_array_dup10 (_tmp1_, value_length1));
	self->priv->_Servers = (_vala_array_free (self->priv->_Servers, self->priv->_Servers_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->_Servers = _tmp0_;
	self->priv->_Servers_length1 = value_length1;
	self->priv->__Servers_size_ = value_length1;
}


DaemonSmtpConfiguration* daemon_configuration_configuration_file_get_Smtp (DaemonConfigurationConfigurationFile* self) {
	DaemonSmtpConfiguration* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Smtp;
	return result;
}


static void daemon_configuration_configuration_file_set_Smtp (DaemonConfigurationConfigurationFile* self, DaemonSmtpConfiguration* value) {
	DaemonSmtpConfiguration* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_Smtp);
	self->priv->_Smtp = _tmp0_;
	g_object_notify ((GObject *) self, "Smtp");
}


static void daemon_configuration_configuration_file_class_init (DaemonConfigurationConfigurationFileClass * klass) {
	daemon_configuration_configuration_file_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DaemonConfigurationConfigurationFilePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_daemon_configuration_configuration_file_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_daemon_configuration_configuration_file_set_property;
	G_OBJECT_CLASS (klass)->finalize = daemon_configuration_configuration_file_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_DISABLE_DAEMON, g_param_spec_boolean ("DisableDaemon", "DisableDaemon", "DisableDaemon", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_LIBRARY, g_param_spec_string ("LogLibrary", "LogLibrary", "LogLibrary", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_FILE, g_param_spec_string ("LogFile", "LogFile", "LogFile", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_NICKNAMES, g_param_spec_boxed ("Nicknames", "Nicknames", "Nicknames", G_TYPE_STRV, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_REAL_NAME, g_param_spec_string ("RealName", "RealName", "RealName", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_HOST, g_param_spec_string ("Host", "Host", "Host", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_USERNAME, g_param_spec_string ("Username", "Username", "Username", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_CONFIGURATION_FILE_SMTP, g_param_spec_object ("Smtp", "Smtp", "Smtp", DAEMON_TYPE_SMTP_CONFIGURATION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void daemon_configuration_configuration_file_instance_init (DaemonConfigurationConfigurationFile * self) {
	self->priv = DAEMON_CONFIGURATION_CONFIGURATION_FILE_GET_PRIVATE (self);
}


static void daemon_configuration_configuration_file_finalize (GObject* obj) {
	DaemonConfigurationConfigurationFile * self;
	self = DAEMON_CONFIGURATION_CONFIGURATION_FILE (obj);
	_g_free0 (self->priv->_LogLibrary);
	_g_free0 (self->priv->_LogFile);
	self->priv->_Nicknames = (_vala_array_free (self->priv->_Nicknames, self->priv->_Nicknames_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->priv->_RealName);
	_g_free0 (self->priv->_Host);
	_g_free0 (self->priv->_Username);
	self->priv->_Servers = (_vala_array_free (self->priv->_Servers, self->priv->_Servers_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (self->priv->_Smtp);
	G_OBJECT_CLASS (daemon_configuration_configuration_file_parent_class)->finalize (obj);
}


GType daemon_configuration_configuration_file_get_type (void) {
	static volatile gsize daemon_configuration_configuration_file_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_configuration_configuration_file_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DaemonConfigurationConfigurationFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) daemon_configuration_configuration_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DaemonConfigurationConfigurationFile), 0, (GInstanceInitFunc) daemon_configuration_configuration_file_instance_init, NULL };
		GType daemon_configuration_configuration_file_type_id;
		daemon_configuration_configuration_file_type_id = g_type_register_static (G_TYPE_OBJECT, "DaemonConfigurationConfigurationFile", &g_define_type_info, 0);
		g_once_init_leave (&daemon_configuration_configuration_file_type_id__volatile, daemon_configuration_configuration_file_type_id);
	}
	return daemon_configuration_configuration_file_type_id__volatile;
}


static void _vala_daemon_configuration_configuration_file_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	DaemonConfigurationConfigurationFile * self;
	int length;
	self = DAEMON_CONFIGURATION_CONFIGURATION_FILE (object);
	switch (property_id) {
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_DISABLE_DAEMON:
		g_value_set_boolean (value, daemon_configuration_configuration_file_get_DisableDaemon (self));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_LIBRARY:
		g_value_set_string (value, daemon_configuration_configuration_file_get_LogLibrary (self));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_FILE:
		g_value_set_string (value, daemon_configuration_configuration_file_get_LogFile (self));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_NICKNAMES:
		g_value_set_boxed (value, daemon_configuration_configuration_file_get_Nicknames (self, &length));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_REAL_NAME:
		g_value_set_string (value, daemon_configuration_configuration_file_get_RealName (self));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_HOST:
		g_value_set_string (value, daemon_configuration_configuration_file_get_Host (self));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_USERNAME:
		g_value_set_string (value, daemon_configuration_configuration_file_get_Username (self));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_SMTP:
		g_value_set_object (value, daemon_configuration_configuration_file_get_Smtp (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_daemon_configuration_configuration_file_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	DaemonConfigurationConfigurationFile * self;
	gpointer boxed;
	self = DAEMON_CONFIGURATION_CONFIGURATION_FILE (object);
	switch (property_id) {
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_DISABLE_DAEMON:
		daemon_configuration_configuration_file_set_DisableDaemon (self, g_value_get_boolean (value));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_LIBRARY:
		daemon_configuration_configuration_file_set_LogLibrary (self, g_value_get_string (value));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_LOG_FILE:
		daemon_configuration_configuration_file_set_LogFile (self, g_value_get_string (value));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_NICKNAMES:
		boxed = g_value_get_boxed (value);
		daemon_configuration_configuration_file_set_Nicknames (self, boxed, g_strv_length (boxed));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_REAL_NAME:
		daemon_configuration_configuration_file_set_RealName (self, g_value_get_string (value));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_HOST:
		daemon_configuration_configuration_file_set_Host (self, g_value_get_string (value));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_USERNAME:
		daemon_configuration_configuration_file_set_Username (self, g_value_get_string (value));
		break;
		case DAEMON_CONFIGURATION_CONFIGURATION_FILE_SMTP:
		daemon_configuration_configuration_file_set_Smtp (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



