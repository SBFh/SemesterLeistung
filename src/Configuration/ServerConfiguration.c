/* ServerConfiguration.c generated by valac 0.12.0, the Vala compiler
 * generated from ServerConfiguration.vala, do not modify */

/*SemesterLeistung - An IRC Daemon
* Copyright (C) 2011  Simon Baumer
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION (daemon_configuration_server_configuration_get_type ())
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfiguration))
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfigurationClass))
#define DAEMON_CONFIGURATION_IS_SERVER_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION))
#define DAEMON_CONFIGURATION_IS_SERVER_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION))
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfigurationClass))

typedef struct _DaemonConfigurationServerConfiguration DaemonConfigurationServerConfiguration;
typedef struct _DaemonConfigurationServerConfigurationClass DaemonConfigurationServerConfigurationClass;
typedef struct _DaemonConfigurationServerConfigurationPrivate DaemonConfigurationServerConfigurationPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _DaemonConfigurationServerConfiguration {
	GObject parent_instance;
	DaemonConfigurationServerConfigurationPrivate * priv;
};

struct _DaemonConfigurationServerConfigurationClass {
	GObjectClass parent_class;
};

struct _DaemonConfigurationServerConfigurationPrivate {
	gchar* _Host;
	guint16 _Port;
	gchar** _Channels;
	gint _Channels_length1;
	gint __Channels_size_;
	gchar* _Name;
};

typedef enum  {
	DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid
} DaemonConfigurationConfigurationError;
#define DAEMON_CONFIGURATION_CONFIGURATION_ERROR daemon_configuration_configuration_error_quark ()
typedef enum  {
	DAEMON_HELPERS_DAEMON_ERROR_ParseFailed
} DaemonHelpersDaemonError;
#define DAEMON_HELPERS_DAEMON_ERROR daemon_helpers_daemon_error_quark ()

static gpointer daemon_configuration_server_configuration_parent_class = NULL;

GType daemon_configuration_server_configuration_get_type (void) G_GNUC_CONST;
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfigurationPrivate))
enum  {
	DAEMON_CONFIGURATION_SERVER_CONFIGURATION_DUMMY_PROPERTY,
	DAEMON_CONFIGURATION_SERVER_CONFIGURATION_HOST,
	DAEMON_CONFIGURATION_SERVER_CONFIGURATION_CHANNELS,
	DAEMON_CONFIGURATION_SERVER_CONFIGURATION_NAME
};
DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_new (const gchar* host, guint16 port, gchar** channels, int channels_length1);
DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_construct (GType object_type, const gchar* host, guint16 port, gchar** channels, int channels_length1);
static void daemon_configuration_server_configuration_set_Host (DaemonConfigurationServerConfiguration* self, const gchar* value);
static void daemon_configuration_server_configuration_set_Port (DaemonConfigurationServerConfiguration* self, guint16 value);
static void daemon_configuration_server_configuration_set_Channels (DaemonConfigurationServerConfiguration* self, gchar** value, int value_length1);
const gchar* daemon_configuration_server_configuration_get_Host (DaemonConfigurationServerConfiguration* self);
guint16 daemon_configuration_server_configuration_get_Port (DaemonConfigurationServerConfiguration* self);
static void daemon_configuration_server_configuration_set_Name (DaemonConfigurationServerConfiguration* self, const gchar* value);
GQuark daemon_configuration_configuration_error_quark (void);
DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_Parse (const gchar* input, GError** error);
GQuark daemon_helpers_daemon_error_quark (void);
void daemon_helpers_typehelper_ParseHostAndPort (const gchar* input, gchar** host, guint16** port, GError** error);
static guint16* _uint16_dup (guint16* self);
gchar* daemon_configuration_server_configuration_ToString (DaemonConfigurationServerConfiguration* self);
gchar** daemon_configuration_server_configuration_get_Channels (DaemonConfigurationServerConfiguration* self, int* result_length1);
static gchar** _vala_array_dup8 (gchar** self, int length);
const gchar* daemon_configuration_server_configuration_get_Name (DaemonConfigurationServerConfiguration* self);
static void daemon_configuration_server_configuration_finalize (GObject* obj);
static void _vala_daemon_configuration_server_configuration_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_daemon_configuration_server_configuration_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_construct (GType object_type, const gchar* host, guint16 port, gchar** channels, int channels_length1) {
	DaemonConfigurationServerConfiguration * self = NULL;
	gchar** _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	g_return_val_if_fail (host != NULL, NULL);
	self = (DaemonConfigurationServerConfiguration*) g_object_new (object_type, NULL);
	daemon_configuration_server_configuration_set_Host (self, host);
	daemon_configuration_server_configuration_set_Port (self, port);
	_tmp0_ = channels;
	daemon_configuration_server_configuration_set_Channels (self, _tmp0_, channels_length1);
	_tmp1_ = g_strconcat (self->priv->_Host, ":", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("%hu", self->priv->_Port);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp2_, _tmp4_, NULL);
	_tmp6_ = _tmp5_;
	daemon_configuration_server_configuration_set_Name (self, _tmp6_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	return self;
}


DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_new (const gchar* host, guint16 port, gchar** channels, int channels_length1) {
	return daemon_configuration_server_configuration_construct (DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, host, port, channels, channels_length1);
}


static guint16* _uint16_dup (guint16* self) {
	guint16* dup;
	dup = g_new0 (guint16, 1);
	memcpy (dup, self, sizeof (guint16));
	return dup;
}


static gpointer __uint16_dup0 (gpointer self) {
	return self ? _uint16_dup (self) : NULL;
}


DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_Parse (const gchar* input, GError** error) {
	DaemonConfigurationServerConfiguration* result = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** parts;
	gint parts_length1;
	gint _parts_size_;
	gboolean _tmp3_ = FALSE;
	gint _tmp4_;
	gchar** _tmp7_;
	gchar** _tmp8_ = NULL;
	gchar** channels;
	gint channels_length1;
	gint _channels_size_;
	gchar* host = NULL;
	guint16* port = NULL;
	gchar* _tmp9_ = NULL;
	guint16* _tmp10_ = NULL;
	guint16* _tmp12_;
	guint16* _tmp13_;
	guint16* _tmp16_;
	DaemonConfigurationServerConfiguration* _tmp17_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (input != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit (input, "/", 0);
	parts = _tmp1_;
	parts_length1 = _vala_array_length (_tmp0_);
	_parts_size_ = _vala_array_length (_tmp0_);
	if (parts_length1 != 2) {
		GError* _tmp2_ = NULL;
		_tmp2_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Invalid format");
		_inner_error_ = _tmp2_;
		if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
			g_propagate_error (error, _inner_error_);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return NULL;
		} else {
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp4_ = strlen (parts[0]);
	if (_tmp4_ == 0) {
		_tmp3_ = TRUE;
	} else {
		gint _tmp5_;
		_tmp5_ = strlen (parts[1]);
		_tmp3_ = _tmp5_ == 0;
	}
	if (_tmp3_) {
		GError* _tmp6_ = NULL;
		_tmp6_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, "Must specify both Server and Channel(s)");
		_inner_error_ = _tmp6_;
		if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
			g_propagate_error (error, _inner_error_);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return NULL;
		} else {
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp8_ = _tmp7_ = g_strsplit (parts[1], ",", 0);
	channels = _tmp8_;
	channels_length1 = _vala_array_length (_tmp7_);
	_channels_size_ = _vala_array_length (_tmp7_);
	daemon_helpers_typehelper_ParseHostAndPort (parts[0], &_tmp9_, &_tmp10_, &_inner_error_);
	_g_free0 (host);
	host = _tmp9_;
	_g_free0 (port);
	port = _tmp10_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_HELPERS_DAEMON_ERROR) {
			goto __catch27_daemon_helpers_daemon_error;
		}
		_g_free0 (port);
		_g_free0 (host);
		channels = (_vala_array_free (channels, channels_length1, (GDestroyNotify) g_free), NULL);
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	goto __finally27;
	__catch27_daemon_helpers_daemon_error:
	{
		GError * _error_;
		GError* _tmp11_ = NULL;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp11_ = g_error_new_literal (DAEMON_CONFIGURATION_CONFIGURATION_ERROR, DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid, _error_->message);
		_inner_error_ = _tmp11_;
		_g_error_free0 (_error_);
		goto __finally27;
	}
	__finally27:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (port);
			_g_free0 (host);
			channels = (_vala_array_free (channels, channels_length1, (GDestroyNotify) g_free), NULL);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return NULL;
		} else {
			_g_free0 (port);
			_g_free0 (host);
			channels = (_vala_array_free (channels, channels_length1, (GDestroyNotify) g_free), NULL);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp12_ = __uint16_dup0 (port);
	_tmp13_ = _tmp12_;
	if (_tmp13_ == NULL) {
		gint _tmp14_;
		guint16* _tmp15_;
		_tmp14_ = 6667;
		_tmp15_ = __uint16_dup0 (&_tmp14_);
		_g_free0 (_tmp13_);
		_tmp13_ = _tmp15_;
	}
	_tmp16_ = __uint16_dup0 (_tmp13_);
	_g_free0 (port);
	port = _tmp16_;
	_tmp17_ = daemon_configuration_server_configuration_new (host, *port, channels, channels_length1);
	result = _tmp17_;
	_g_free0 (_tmp13_);
	_g_free0 (port);
	_g_free0 (host);
	channels = (_vala_array_free (channels, channels_length1, (GDestroyNotify) g_free), NULL);
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


gchar* daemon_configuration_server_configuration_ToString (DaemonConfigurationServerConfiguration* self) {
	gchar* result = NULL;
	GString* _tmp0_ = NULL;
	GString* builder;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gchar** _tmp4_ = NULL;
	gint _tmp5_;
	gchar* _tmp15_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	g_string_append (builder, "{\n\t");
	g_string_append (builder, "Host: ");
	g_string_append (builder, self->priv->_Host);
	g_string_append (builder, ",\n\t");
	g_string_append (builder, "Port: ");
	_tmp1_ = g_strdup_printf ("%hu", self->priv->_Port);
	_tmp2_ = _tmp1_;
	g_string_append (builder, _tmp2_);
	_g_free0 (_tmp2_);
	_tmp4_ = daemon_configuration_server_configuration_get_Channels (self, &_tmp5_);
	if (_tmp4_ != NULL) {
		gchar** _tmp6_ = NULL;
		gint _tmp7_;
		_tmp6_ = daemon_configuration_server_configuration_get_Channels (self, &_tmp7_);
		_tmp3_ = _tmp7_ > 0;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		g_string_append (builder, ",\n\tChannels:\n\t[");
		g_string_append (builder, "\n\t\t");
		{
			gint i;
			i = 0;
			{
				gboolean _tmp8_;
				_tmp8_ = TRUE;
				while (TRUE) {
					gchar** _tmp9_ = NULL;
					gint _tmp10_;
					gchar** _tmp11_ = NULL;
					gint _tmp12_;
					gchar** _tmp13_ = NULL;
					gint _tmp14_;
					if (!_tmp8_) {
						i++;
					}
					_tmp8_ = FALSE;
					_tmp9_ = daemon_configuration_server_configuration_get_Channels (self, &_tmp10_);
					if (!(i < _tmp10_)) {
						break;
					}
					_tmp11_ = daemon_configuration_server_configuration_get_Channels (self, &_tmp12_);
					g_string_append (builder, _tmp11_[i]);
					_tmp13_ = daemon_configuration_server_configuration_get_Channels (self, &_tmp14_);
					if (i < (_tmp14_ - 1)) {
						g_string_append (builder, ",\n\t\t");
					}
				}
			}
		}
		g_string_append (builder, "\n\t]");
	}
	g_string_append (builder, "\n}");
	_tmp15_ = g_strdup (builder->str);
	result = _tmp15_;
	_g_string_free0 (builder);
	return result;
}


const gchar* daemon_configuration_server_configuration_get_Host (DaemonConfigurationServerConfiguration* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Host;
	return result;
}


static void daemon_configuration_server_configuration_set_Host (DaemonConfigurationServerConfiguration* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Host);
	self->priv->_Host = _tmp0_;
	g_object_notify ((GObject *) self, "Host");
}


guint16 daemon_configuration_server_configuration_get_Port (DaemonConfigurationServerConfiguration* self) {
	guint16 result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_Port;
	return result;
}


static void daemon_configuration_server_configuration_set_Port (DaemonConfigurationServerConfiguration* self, guint16 value) {
	g_return_if_fail (self != NULL);
	self->priv->_Port = value;
}


gchar** daemon_configuration_server_configuration_get_Channels (DaemonConfigurationServerConfiguration* self, int* result_length1) {
	gchar** result;
	gchar** _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_Channels;
	*result_length1 = self->priv->_Channels_length1;
	result = _tmp0_;
	return result;
}


static gchar** _vala_array_dup8 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static void daemon_configuration_server_configuration_set_Channels (DaemonConfigurationServerConfiguration* self, gchar** value, int value_length1) {
	gchar** _tmp0_;
	gchar** _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = (_tmp1_ = value, (_tmp1_ == NULL) ? ((gpointer) _tmp1_) : _vala_array_dup8 (_tmp1_, value_length1));
	self->priv->_Channels = (_vala_array_free (self->priv->_Channels, self->priv->_Channels_length1, (GDestroyNotify) g_free), NULL);
	self->priv->_Channels = _tmp0_;
	self->priv->_Channels_length1 = value_length1;
	self->priv->__Channels_size_ = value_length1;
	g_object_notify ((GObject *) self, "Channels");
}


const gchar* daemon_configuration_server_configuration_get_Name (DaemonConfigurationServerConfiguration* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Name;
	return result;
}


static void daemon_configuration_server_configuration_set_Name (DaemonConfigurationServerConfiguration* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Name);
	self->priv->_Name = _tmp0_;
	g_object_notify ((GObject *) self, "Name");
}


static void daemon_configuration_server_configuration_class_init (DaemonConfigurationServerConfigurationClass * klass) {
	daemon_configuration_server_configuration_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DaemonConfigurationServerConfigurationPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_daemon_configuration_server_configuration_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_daemon_configuration_server_configuration_set_property;
	G_OBJECT_CLASS (klass)->finalize = daemon_configuration_server_configuration_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_SERVER_CONFIGURATION_HOST, g_param_spec_string ("Host", "Host", "Host", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_SERVER_CONFIGURATION_CHANNELS, g_param_spec_boxed ("Channels", "Channels", "Channels", G_TYPE_STRV, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_CONFIGURATION_SERVER_CONFIGURATION_NAME, g_param_spec_string ("Name", "Name", "Name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void daemon_configuration_server_configuration_instance_init (DaemonConfigurationServerConfiguration * self) {
	self->priv = DAEMON_CONFIGURATION_SERVER_CONFIGURATION_GET_PRIVATE (self);
}


static void daemon_configuration_server_configuration_finalize (GObject* obj) {
	DaemonConfigurationServerConfiguration * self;
	self = DAEMON_CONFIGURATION_SERVER_CONFIGURATION (obj);
	_g_free0 (self->priv->_Host);
	self->priv->_Channels = (_vala_array_free (self->priv->_Channels, self->priv->_Channels_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->priv->_Name);
	G_OBJECT_CLASS (daemon_configuration_server_configuration_parent_class)->finalize (obj);
}


GType daemon_configuration_server_configuration_get_type (void) {
	static volatile gsize daemon_configuration_server_configuration_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_configuration_server_configuration_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DaemonConfigurationServerConfigurationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) daemon_configuration_server_configuration_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DaemonConfigurationServerConfiguration), 0, (GInstanceInitFunc) daemon_configuration_server_configuration_instance_init, NULL };
		GType daemon_configuration_server_configuration_type_id;
		daemon_configuration_server_configuration_type_id = g_type_register_static (G_TYPE_OBJECT, "DaemonConfigurationServerConfiguration", &g_define_type_info, 0);
		g_once_init_leave (&daemon_configuration_server_configuration_type_id__volatile, daemon_configuration_server_configuration_type_id);
	}
	return daemon_configuration_server_configuration_type_id__volatile;
}


static void _vala_daemon_configuration_server_configuration_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	DaemonConfigurationServerConfiguration * self;
	int length;
	self = DAEMON_CONFIGURATION_SERVER_CONFIGURATION (object);
	switch (property_id) {
		case DAEMON_CONFIGURATION_SERVER_CONFIGURATION_HOST:
		g_value_set_string (value, daemon_configuration_server_configuration_get_Host (self));
		break;
		case DAEMON_CONFIGURATION_SERVER_CONFIGURATION_CHANNELS:
		g_value_set_boxed (value, daemon_configuration_server_configuration_get_Channels (self, &length));
		break;
		case DAEMON_CONFIGURATION_SERVER_CONFIGURATION_NAME:
		g_value_set_string (value, daemon_configuration_server_configuration_get_Name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_daemon_configuration_server_configuration_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	DaemonConfigurationServerConfiguration * self;
	gpointer boxed;
	self = DAEMON_CONFIGURATION_SERVER_CONFIGURATION (object);
	switch (property_id) {
		case DAEMON_CONFIGURATION_SERVER_CONFIGURATION_HOST:
		daemon_configuration_server_configuration_set_Host (self, g_value_get_string (value));
		break;
		case DAEMON_CONFIGURATION_SERVER_CONFIGURATION_CHANNELS:
		boxed = g_value_get_boxed (value);
		daemon_configuration_server_configuration_set_Channels (self, boxed, g_strv_length (boxed));
		break;
		case DAEMON_CONFIGURATION_SERVER_CONFIGURATION_NAME:
		daemon_configuration_server_configuration_set_Name (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



