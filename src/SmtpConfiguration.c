/* SmtpConfiguration.c generated by valac 0.12.0, the Vala compiler
 * generated from SmtpConfiguration.vala, do not modify */

/*SemesterLeistung - An IRC Daemon
* Copyright (C) 2011  Simon Baumer
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define DAEMON_TYPE_ENCRYPTION_TYPES (daemon_encryption_types_get_type ())

#define DAEMON_TYPE_SMTP_CONFIGURATION (daemon_smtp_configuration_get_type ())
#define DAEMON_SMTP_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfiguration))
#define DAEMON_SMTP_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfigurationClass))
#define DAEMON_IS_SMTP_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_TYPE_SMTP_CONFIGURATION))
#define DAEMON_IS_SMTP_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_TYPE_SMTP_CONFIGURATION))
#define DAEMON_SMTP_CONFIGURATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfigurationClass))

typedef struct _DaemonSmtpConfiguration DaemonSmtpConfiguration;
typedef struct _DaemonSmtpConfigurationClass DaemonSmtpConfigurationClass;
typedef struct _DaemonSmtpConfigurationPrivate DaemonSmtpConfigurationPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef enum  {
	DAEMON_SMTP_ERROR_InvalidConfiguration
} DaemonSmtpError;
#define DAEMON_SMTP_ERROR daemon_smtp_error_quark ()
typedef enum  {
	DAEMON_ENCRYPTION_TYPES_None = 0,
	DAEMON_ENCRYPTION_TYPES_SSL = 1,
	DAEMON_ENCRYPTION_TYPES_TLS = 2
} DaemonEncryptionTypes;

struct _DaemonSmtpConfiguration {
	GObject parent_instance;
	DaemonSmtpConfigurationPrivate * priv;
};

struct _DaemonSmtpConfigurationClass {
	GObjectClass parent_class;
};

struct _DaemonSmtpConfigurationPrivate {
	gchar* _Sender;
	gchar* _Host;
	guint16 _Port;
};

typedef enum  {
	DAEMON_HELPERS_DAEMON_ERROR_ParseFailed
} DaemonHelpersDaemonError;
#define DAEMON_HELPERS_DAEMON_ERROR daemon_helpers_daemon_error_quark ()

static gpointer daemon_smtp_configuration_parent_class = NULL;

GQuark daemon_smtp_error_quark (void);
GType daemon_encryption_types_get_type (void) G_GNUC_CONST;
GType daemon_smtp_configuration_get_type (void) G_GNUC_CONST;
#define DAEMON_SMTP_CONFIGURATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfigurationPrivate))
enum  {
	DAEMON_SMTP_CONFIGURATION_DUMMY_PROPERTY,
	DAEMON_SMTP_CONFIGURATION_SENDER,
	DAEMON_SMTP_CONFIGURATION_HOST
};
DaemonSmtpConfiguration* daemon_smtp_configuration_new (const gchar* sender, const gchar* host, guint16 port);
DaemonSmtpConfiguration* daemon_smtp_configuration_construct (GType object_type, const gchar* sender, const gchar* host, guint16 port);
static void daemon_smtp_configuration_set_Sender (DaemonSmtpConfiguration* self, const gchar* value);
static void daemon_smtp_configuration_set_Host (DaemonSmtpConfiguration* self, const gchar* value);
static void daemon_smtp_configuration_set_Port (DaemonSmtpConfiguration* self, guint16 value);
gchar* daemon_smtp_configuration_ToString (DaemonSmtpConfiguration* self);
const gchar* daemon_smtp_configuration_get_Host (DaemonSmtpConfiguration* self);
guint16 daemon_smtp_configuration_get_Port (DaemonSmtpConfiguration* self);
const gchar* daemon_smtp_configuration_get_Sender (DaemonSmtpConfiguration* self);
DaemonSmtpConfiguration* daemon_smtp_configuration_Parse (const gchar* input, GError** error);
GQuark daemon_helpers_daemon_error_quark (void);
void daemon_helpers_typehelper_ParseHostAndPort (const gchar* input, gchar** host, guint16** port, GError** error);
static guint16* _uint16_dup (guint16* self);
static void daemon_smtp_configuration_finalize (GObject* obj);
static void _vala_daemon_smtp_configuration_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_daemon_smtp_configuration_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GQuark daemon_smtp_error_quark (void) {
	return g_quark_from_static_string ("daemon_smtp_error-quark");
}


GType daemon_encryption_types_get_type (void) {
	static volatile gsize daemon_encryption_types_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_encryption_types_type_id__volatile)) {
		static const GEnumValue values[] = {{DAEMON_ENCRYPTION_TYPES_None, "DAEMON_ENCRYPTION_TYPES_None", "none"}, {DAEMON_ENCRYPTION_TYPES_SSL, "DAEMON_ENCRYPTION_TYPES_SSL", "ssl"}, {DAEMON_ENCRYPTION_TYPES_TLS, "DAEMON_ENCRYPTION_TYPES_TLS", "tls"}, {0, NULL, NULL}};
		GType daemon_encryption_types_type_id;
		daemon_encryption_types_type_id = g_enum_register_static ("DaemonEncryptionTypes", values);
		g_once_init_leave (&daemon_encryption_types_type_id__volatile, daemon_encryption_types_type_id);
	}
	return daemon_encryption_types_type_id__volatile;
}


DaemonSmtpConfiguration* daemon_smtp_configuration_construct (GType object_type, const gchar* sender, const gchar* host, guint16 port) {
	DaemonSmtpConfiguration * self = NULL;
	g_return_val_if_fail (sender != NULL, NULL);
	g_return_val_if_fail (host != NULL, NULL);
	self = (DaemonSmtpConfiguration*) g_object_new (object_type, NULL);
	daemon_smtp_configuration_set_Sender (self, sender);
	daemon_smtp_configuration_set_Host (self, host);
	daemon_smtp_configuration_set_Port (self, port);
	return self;
}


DaemonSmtpConfiguration* daemon_smtp_configuration_new (const gchar* sender, const gchar* host, guint16 port) {
	return daemon_smtp_configuration_construct (DAEMON_TYPE_SMTP_CONFIGURATION, sender, host, port);
}


gchar* daemon_smtp_configuration_ToString (DaemonSmtpConfiguration* self) {
	gchar* result = NULL;
	GString* _tmp0_ = NULL;
	GString* builder;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	g_string_append (builder, "{\n\t");
	g_string_append (builder, "Host: ");
	g_string_append (builder, self->priv->_Host);
	g_string_append (builder, ",\n\t");
	g_string_append (builder, "Port: ");
	_tmp1_ = g_strdup_printf ("%hu", self->priv->_Port);
	_tmp2_ = _tmp1_;
	g_string_append (builder, _tmp2_);
	_g_free0 (_tmp2_);
	g_string_append (builder, ",\n\t");
	g_string_append (builder, "Sender: ");
	g_string_append (builder, self->priv->_Sender);
	g_string_append (builder, "\n}");
	_tmp3_ = g_strdup (builder->str);
	result = _tmp3_;
	_g_string_free0 (builder);
	return result;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static guint16* _uint16_dup (guint16* self) {
	guint16* dup;
	dup = g_new0 (guint16, 1);
	memcpy (dup, self, sizeof (guint16));
	return dup;
}


static gpointer __uint16_dup0 (gpointer self) {
	return self ? _uint16_dup (self) : NULL;
}


DaemonSmtpConfiguration* daemon_smtp_configuration_Parse (const gchar* input, GError** error) {
	DaemonSmtpConfiguration* result = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** parts;
	gint parts_length1;
	gint _parts_size_;
	gchar* _tmp3_ = NULL;
	gchar* sender;
	gint _tmp4_;
	gchar* host = NULL;
	guint16* port = NULL;
	gchar* _tmp6_ = NULL;
	guint16* _tmp7_ = NULL;
	guint16* _tmp9_;
	guint16* _tmp10_;
	guint16* _tmp13_;
	DaemonSmtpConfiguration* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (input != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit (input, "/", 0);
	parts = _tmp1_;
	parts_length1 = _vala_array_length (_tmp0_);
	_parts_size_ = _vala_array_length (_tmp0_);
	if (parts_length1 != 2) {
		GError* _tmp2_ = NULL;
		_tmp2_ = g_error_new_literal (DAEMON_SMTP_ERROR, DAEMON_SMTP_ERROR_InvalidConfiguration, "Invalid configuration string");
		_inner_error_ = _tmp2_;
		if (_inner_error_->domain == DAEMON_SMTP_ERROR) {
			g_propagate_error (error, _inner_error_);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return NULL;
		} else {
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = string_strip (parts[0]);
	sender = _tmp3_;
	_tmp4_ = strlen (sender);
	if (_tmp4_ == 0) {
		GError* _tmp5_ = NULL;
		_tmp5_ = g_error_new_literal (DAEMON_SMTP_ERROR, DAEMON_SMTP_ERROR_InvalidConfiguration, "Invalid configuration string");
		_inner_error_ = _tmp5_;
		if (_inner_error_->domain == DAEMON_SMTP_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (sender);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return NULL;
		} else {
			_g_free0 (sender);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	daemon_helpers_typehelper_ParseHostAndPort (parts[1], &_tmp6_, &_tmp7_, &_inner_error_);
	_g_free0 (host);
	host = _tmp6_;
	_g_free0 (port);
	port = _tmp7_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_HELPERS_DAEMON_ERROR) {
			goto __catch8_daemon_helpers_daemon_error;
		}
		_g_free0 (port);
		_g_free0 (host);
		_g_free0 (sender);
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	goto __finally8;
	__catch8_daemon_helpers_daemon_error:
	{
		GError * _error_;
		GError* _tmp8_ = NULL;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = g_error_new_literal (DAEMON_SMTP_ERROR, DAEMON_SMTP_ERROR_InvalidConfiguration, _error_->message);
		_inner_error_ = _tmp8_;
		_g_error_free0 (_error_);
		goto __finally8;
	}
	__finally8:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_SMTP_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (port);
			_g_free0 (host);
			_g_free0 (sender);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return NULL;
		} else {
			_g_free0 (port);
			_g_free0 (host);
			_g_free0 (sender);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp9_ = __uint16_dup0 (port);
	_tmp10_ = _tmp9_;
	if (_tmp10_ == NULL) {
		gint _tmp11_;
		guint16* _tmp12_;
		_tmp11_ = 25;
		_tmp12_ = __uint16_dup0 (&_tmp11_);
		_g_free0 (_tmp10_);
		_tmp10_ = _tmp12_;
	}
	_tmp13_ = __uint16_dup0 (_tmp10_);
	_g_free0 (port);
	port = _tmp13_;
	_tmp14_ = daemon_smtp_configuration_new (sender, host, *port);
	result = _tmp14_;
	_g_free0 (_tmp10_);
	_g_free0 (port);
	_g_free0 (host);
	_g_free0 (sender);
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


const gchar* daemon_smtp_configuration_get_Sender (DaemonSmtpConfiguration* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Sender;
	return result;
}


static void daemon_smtp_configuration_set_Sender (DaemonSmtpConfiguration* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Sender);
	self->priv->_Sender = _tmp0_;
	g_object_notify ((GObject *) self, "Sender");
}


const gchar* daemon_smtp_configuration_get_Host (DaemonSmtpConfiguration* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_Host;
	return result;
}


static void daemon_smtp_configuration_set_Host (DaemonSmtpConfiguration* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_Host);
	self->priv->_Host = _tmp0_;
	g_object_notify ((GObject *) self, "Host");
}


guint16 daemon_smtp_configuration_get_Port (DaemonSmtpConfiguration* self) {
	guint16 result;
	g_return_val_if_fail (self != NULL, 0U);
	result = self->priv->_Port;
	return result;
}


static void daemon_smtp_configuration_set_Port (DaemonSmtpConfiguration* self, guint16 value) {
	g_return_if_fail (self != NULL);
	self->priv->_Port = value;
}


static void daemon_smtp_configuration_class_init (DaemonSmtpConfigurationClass * klass) {
	daemon_smtp_configuration_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DaemonSmtpConfigurationPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_daemon_smtp_configuration_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_daemon_smtp_configuration_set_property;
	G_OBJECT_CLASS (klass)->finalize = daemon_smtp_configuration_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_SMTP_CONFIGURATION_SENDER, g_param_spec_string ("Sender", "Sender", "Sender", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DAEMON_SMTP_CONFIGURATION_HOST, g_param_spec_string ("Host", "Host", "Host", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void daemon_smtp_configuration_instance_init (DaemonSmtpConfiguration * self) {
	self->priv = DAEMON_SMTP_CONFIGURATION_GET_PRIVATE (self);
}


static void daemon_smtp_configuration_finalize (GObject* obj) {
	DaemonSmtpConfiguration * self;
	self = DAEMON_SMTP_CONFIGURATION (obj);
	_g_free0 (self->priv->_Sender);
	_g_free0 (self->priv->_Host);
	G_OBJECT_CLASS (daemon_smtp_configuration_parent_class)->finalize (obj);
}


GType daemon_smtp_configuration_get_type (void) {
	static volatile gsize daemon_smtp_configuration_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_smtp_configuration_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DaemonSmtpConfigurationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) daemon_smtp_configuration_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DaemonSmtpConfiguration), 0, (GInstanceInitFunc) daemon_smtp_configuration_instance_init, NULL };
		GType daemon_smtp_configuration_type_id;
		daemon_smtp_configuration_type_id = g_type_register_static (G_TYPE_OBJECT, "DaemonSmtpConfiguration", &g_define_type_info, 0);
		g_once_init_leave (&daemon_smtp_configuration_type_id__volatile, daemon_smtp_configuration_type_id);
	}
	return daemon_smtp_configuration_type_id__volatile;
}


static void _vala_daemon_smtp_configuration_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	DaemonSmtpConfiguration * self;
	self = DAEMON_SMTP_CONFIGURATION (object);
	switch (property_id) {
		case DAEMON_SMTP_CONFIGURATION_SENDER:
		g_value_set_string (value, daemon_smtp_configuration_get_Sender (self));
		break;
		case DAEMON_SMTP_CONFIGURATION_HOST:
		g_value_set_string (value, daemon_smtp_configuration_get_Host (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_daemon_smtp_configuration_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	DaemonSmtpConfiguration * self;
	self = DAEMON_SMTP_CONFIGURATION (object);
	switch (property_id) {
		case DAEMON_SMTP_CONFIGURATION_SENDER:
		daemon_smtp_configuration_set_Sender (self, g_value_get_string (value));
		break;
		case DAEMON_SMTP_CONFIGURATION_HOST:
		daemon_smtp_configuration_set_Host (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



