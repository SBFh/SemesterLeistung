/* GlobalLog.c generated by valac 0.12.0, the Vala compiler
 * generated from GlobalLog.vala, do not modify */

/*SemesterLeistung - An IRC Daemon
* Copyright (C) 2011  Simon Baumer
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>


#define DAEMON_TYPE_CONSOLE_COLORS (daemon_console_colors_get_type ())

#define DAEMON_TYPE_GLOBAL_LOG (daemon_global_log_get_type ())
#define DAEMON_GLOBAL_LOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_TYPE_GLOBAL_LOG, DaemonGlobalLog))
#define DAEMON_GLOBAL_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_TYPE_GLOBAL_LOG, DaemonGlobalLogClass))
#define DAEMON_IS_GLOBAL_LOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_TYPE_GLOBAL_LOG))
#define DAEMON_IS_GLOBAL_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_TYPE_GLOBAL_LOG))
#define DAEMON_GLOBAL_LOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_TYPE_GLOBAL_LOG, DaemonGlobalLogClass))

typedef struct _DaemonGlobalLog DaemonGlobalLog;
typedef struct _DaemonGlobalLogClass DaemonGlobalLogClass;
typedef struct _DaemonGlobalLogPrivate DaemonGlobalLogPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

typedef enum  {
	DAEMON_CONSOLE_COLORS_Red = 31,
	DAEMON_CONSOLE_COLORS_Green = 32,
	DAEMON_CONSOLE_COLORS_Yellow = 33,
	DAEMON_CONSOLE_COLORS_Blue = 34,
	DAEMON_CONSOLE_COLORS_Purple = 35,
	DAEMON_CONSOLE_COLORS_Cyan = 36,
	DAEMON_CONSOLE_COLORS_White = 37
} DaemonConsoleColors;

struct _DaemonGlobalLog {
	GObject parent_instance;
	DaemonGlobalLogPrivate * priv;
};

struct _DaemonGlobalLogClass {
	GObjectClass parent_class;
};


static gpointer daemon_global_log_parent_class = NULL;

GType daemon_console_colors_get_type (void) G_GNUC_CONST;
GType daemon_global_log_get_type (void) G_GNUC_CONST;
enum  {
	DAEMON_GLOBAL_LOG_DUMMY_PROPERTY
};
static void daemon_global_log_SetConsoleColor (DaemonConsoleColors color);
static void daemon_global_log_ResetConsoleColor (void);
void daemon_global_log_Message (const gchar* format, ...);
static void daemon_global_log_Print (DaemonConsoleColors* color, const gchar* prefix, const gchar* format, va_list args);
void daemon_global_log_ColorMessage (DaemonConsoleColors color, const gchar* format, ...);
void daemon_global_log_Error (const gchar* format, ...);
void daemon_global_log_Warning (const gchar* format, ...);
DaemonGlobalLog* daemon_global_log_new (void);
DaemonGlobalLog* daemon_global_log_construct (GType object_type);


GType daemon_console_colors_get_type (void) {
	static volatile gsize daemon_console_colors_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_console_colors_type_id__volatile)) {
		static const GEnumValue values[] = {{DAEMON_CONSOLE_COLORS_Red, "DAEMON_CONSOLE_COLORS_Red", "red"}, {DAEMON_CONSOLE_COLORS_Green, "DAEMON_CONSOLE_COLORS_Green", "green"}, {DAEMON_CONSOLE_COLORS_Yellow, "DAEMON_CONSOLE_COLORS_Yellow", "yellow"}, {DAEMON_CONSOLE_COLORS_Blue, "DAEMON_CONSOLE_COLORS_Blue", "blue"}, {DAEMON_CONSOLE_COLORS_Purple, "DAEMON_CONSOLE_COLORS_Purple", "purple"}, {DAEMON_CONSOLE_COLORS_Cyan, "DAEMON_CONSOLE_COLORS_Cyan", "cyan"}, {DAEMON_CONSOLE_COLORS_White, "DAEMON_CONSOLE_COLORS_White", "white"}, {0, NULL, NULL}};
		GType daemon_console_colors_type_id;
		daemon_console_colors_type_id = g_enum_register_static ("DaemonConsoleColors", values);
		g_once_init_leave (&daemon_console_colors_type_id__volatile, daemon_console_colors_type_id);
	}
	return daemon_console_colors_type_id__volatile;
}


static void daemon_global_log_SetConsoleColor (DaemonConsoleColors color) {
	fprintf (stdout, "\033[1;%dm", (gint) color);
}


static void daemon_global_log_ResetConsoleColor (void) {
	fprintf (stdout, "\033[0m");
}


void daemon_global_log_Message (const gchar* format, ...) {
	va_list _tmp0_;
	va_list _tmp1_;
	va_list _tmp2_;
	g_return_if_fail (format != NULL);
	va_start (_tmp0_, format);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	daemon_global_log_Print (NULL, "", format, _tmp2_);
	va_end (_tmp2_);
}


void daemon_global_log_ColorMessage (DaemonConsoleColors color, const gchar* format, ...) {
	va_list _tmp0_;
	va_list _tmp1_;
	va_list _tmp2_;
	g_return_if_fail (format != NULL);
	va_start (_tmp0_, format);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	daemon_global_log_Print (&color, "", format, _tmp2_);
	va_end (_tmp2_);
}


void daemon_global_log_Error (const gchar* format, ...) {
	DaemonConsoleColors _tmp0_;
	va_list _tmp1_;
	va_list _tmp2_;
	va_list _tmp3_;
	g_return_if_fail (format != NULL);
	_tmp0_ = DAEMON_CONSOLE_COLORS_Red;
	va_start (_tmp1_, format);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	daemon_global_log_Print (&_tmp0_, "Error: ", format, _tmp3_);
	va_end (_tmp3_);
}


void daemon_global_log_Warning (const gchar* format, ...) {
	DaemonConsoleColors _tmp0_;
	va_list _tmp1_;
	va_list _tmp2_;
	va_list _tmp3_;
	g_return_if_fail (format != NULL);
	_tmp0_ = DAEMON_CONSOLE_COLORS_Yellow;
	va_start (_tmp1_, format);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	daemon_global_log_Print (&_tmp0_, "Warning: ", format, _tmp3_);
	va_end (_tmp3_);
}


static void daemon_global_log_Print (DaemonConsoleColors* color, const gchar* prefix, const gchar* format, va_list args) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_if_fail (prefix != NULL);
	g_return_if_fail (format != NULL);
	if (color != NULL) {
		daemon_global_log_SetConsoleColor (*color);
	}
	_tmp0_ = g_strconcat (prefix, format, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat (_tmp1_, "\n", NULL);
	_tmp3_ = _tmp2_;
	vfprintf (stdout, _tmp3_, args);
	_g_free0 (_tmp3_);
	_g_free0 (_tmp1_);
	if (color != NULL) {
		daemon_global_log_ResetConsoleColor ();
	}
}


DaemonGlobalLog* daemon_global_log_construct (GType object_type) {
	DaemonGlobalLog * self = NULL;
	self = (DaemonGlobalLog*) g_object_new (object_type, NULL);
	return self;
}


DaemonGlobalLog* daemon_global_log_new (void) {
	return daemon_global_log_construct (DAEMON_TYPE_GLOBAL_LOG);
}


static void daemon_global_log_class_init (DaemonGlobalLogClass * klass) {
	daemon_global_log_parent_class = g_type_class_peek_parent (klass);
}


static void daemon_global_log_instance_init (DaemonGlobalLog * self) {
}


GType daemon_global_log_get_type (void) {
	static volatile gsize daemon_global_log_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_global_log_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DaemonGlobalLogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) daemon_global_log_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DaemonGlobalLog), 0, (GInstanceInitFunc) daemon_global_log_instance_init, NULL };
		GType daemon_global_log_type_id;
		daemon_global_log_type_id = g_type_register_static (G_TYPE_OBJECT, "DaemonGlobalLog", &g_define_type_info, 0);
		g_once_init_leave (&daemon_global_log_type_id__volatile, daemon_global_log_type_id);
	}
	return daemon_global_log_type_id__volatile;
}



