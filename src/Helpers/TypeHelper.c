/* TypeHelper.c generated by valac 0.12.0, the Vala compiler
 * generated from TypeHelper.vala, do not modify */

/*SemesterLeistung - An IRC Daemon
* Copyright (C) 2011  Simon Baumer
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define DAEMON_HELPERS_TYPE_TYPEHELPER (daemon_helpers_typehelper_get_type ())
#define DAEMON_HELPERS_TYPEHELPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_HELPERS_TYPE_TYPEHELPER, DaemonHelpersTypeHelper))
#define DAEMON_HELPERS_TYPEHELPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_HELPERS_TYPE_TYPEHELPER, DaemonHelpersTypeHelperClass))
#define DAEMON_HELPERS_IS_TYPEHELPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_HELPERS_TYPE_TYPEHELPER))
#define DAEMON_HELPERS_IS_TYPEHELPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_HELPERS_TYPE_TYPEHELPER))
#define DAEMON_HELPERS_TYPEHELPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_HELPERS_TYPE_TYPEHELPER, DaemonHelpersTypeHelperClass))

typedef struct _DaemonHelpersTypeHelper DaemonHelpersTypeHelper;
typedef struct _DaemonHelpersTypeHelperClass DaemonHelpersTypeHelperClass;
typedef struct _DaemonHelpersTypeHelperPrivate DaemonHelpersTypeHelperPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

typedef enum  {
	DAEMON_HELPERS_DAEMON_ERROR_ParseFailed
} DaemonHelpersDaemonError;
#define DAEMON_HELPERS_DAEMON_ERROR daemon_helpers_daemon_error_quark ()
struct _DaemonHelpersTypeHelper {
	GObject parent_instance;
	DaemonHelpersTypeHelperPrivate * priv;
};

struct _DaemonHelpersTypeHelperClass {
	GObjectClass parent_class;
};


static gpointer daemon_helpers_typehelper_parent_class = NULL;

GQuark daemon_helpers_daemon_error_quark (void);
GType daemon_helpers_typehelper_get_type (void) G_GNUC_CONST;
enum  {
	DAEMON_HELPERS_TYPEHELPER_DUMMY_PROPERTY
};
guint16* daemon_helpers_typehelper_ParsePort (const gchar* text);
gboolean daemon_helpers_typehelper_IsNumeric (const gchar* text);
static guint16* _uint16_dup (guint16* self);
void daemon_helpers_typehelper_ParseHostAndPort (const gchar* input, gchar** host, guint16** port, GError** error);
gchar* daemon_helpers_typehelper_IndentString (const gchar* text, gint count);
DaemonHelpersTypeHelper* daemon_helpers_typehelper_new (void);
DaemonHelpersTypeHelper* daemon_helpers_typehelper_construct (GType object_type);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GQuark daemon_helpers_daemon_error_quark (void) {
	return g_quark_from_static_string ("daemon_helpers_daemon_error-quark");
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static guint16* _uint16_dup (guint16* self) {
	guint16* dup;
	dup = g_new0 (guint16, 1);
	memcpy (dup, self, sizeof (guint16));
	return dup;
}


static gpointer __uint16_dup0 (gpointer self) {
	return self ? _uint16_dup (self) : NULL;
}


guint16* daemon_helpers_typehelper_ParsePort (const gchar* text) {
	guint16* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* input;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_;
	gint _tmp4_;
	gint port;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	guint16 _tmp7_;
	guint16* _tmp8_;
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = string_strip (text);
	input = _tmp0_;
	_tmp2_ = strlen (input);
	if (_tmp2_ == 0) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp3_;
		_tmp3_ = daemon_helpers_typehelper_IsNumeric (input);
		_tmp1_ = !_tmp3_;
	}
	if (_tmp1_) {
		result = NULL;
		_g_free0 (input);
		return result;
	}
	_tmp4_ = atoi (input);
	port = _tmp4_;
	if (port < 0) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = port < 0U;
	}
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		_tmp5_ = port > G_MAXUINT16;
	}
	if (_tmp5_) {
		result = NULL;
		_g_free0 (input);
		return result;
	}
	_tmp7_ = (guint16) port;
	_tmp8_ = __uint16_dup0 (&_tmp7_);
	result = _tmp8_;
	_g_free0 (input);
	return result;
}


void daemon_helpers_typehelper_ParseHostAndPort (const gchar* input, gchar** host, guint16** port, GError** error) {
	gchar* _host = NULL;
	guint16* _port = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** parts;
	gint parts_length1;
	gint _parts_size_;
	gchar* _tmp3_ = NULL;
	gint _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (input != NULL);
	_tmp1_ = _tmp0_ = g_strsplit (input, ":", 0);
	parts = _tmp1_;
	parts_length1 = _vala_array_length (_tmp0_);
	_parts_size_ = _vala_array_length (_tmp0_);
	if (parts_length1 > 2) {
		GError* _tmp2_ = NULL;
		_tmp2_ = g_error_new_literal (DAEMON_HELPERS_DAEMON_ERROR, DAEMON_HELPERS_DAEMON_ERROR_ParseFailed, "Invalid host");
		_inner_error_ = _tmp2_;
		if (_inner_error_->domain == DAEMON_HELPERS_DAEMON_ERROR) {
			g_propagate_error (error, _inner_error_);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return;
		} else {
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp3_ = string_strip (parts[0]);
	_g_free0 (_host);
	_host = _tmp3_;
	_tmp4_ = strlen (_host);
	if (_tmp4_ == 0) {
		GError* _tmp5_ = NULL;
		_tmp5_ = g_error_new_literal (DAEMON_HELPERS_DAEMON_ERROR, DAEMON_HELPERS_DAEMON_ERROR_ParseFailed, "Invalid host");
		_inner_error_ = _tmp5_;
		if (_inner_error_->domain == DAEMON_HELPERS_DAEMON_ERROR) {
			g_propagate_error (error, _inner_error_);
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			return;
		} else {
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (parts_length1 == 2) {
		guint16* _tmp6_ = NULL;
		_tmp6_ = daemon_helpers_typehelper_ParsePort (parts[1]);
		_g_free0 (_port);
		_port = _tmp6_;
		if (_port == NULL) {
			GError* _tmp7_ = NULL;
			_tmp7_ = g_error_new_literal (DAEMON_HELPERS_DAEMON_ERROR, DAEMON_HELPERS_DAEMON_ERROR_ParseFailed, "Could not parse port");
			_inner_error_ = _tmp7_;
			if (_inner_error_->domain == DAEMON_HELPERS_DAEMON_ERROR) {
				g_propagate_error (error, _inner_error_);
				parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
				return;
			} else {
				parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	if (host) {
		*host = _host;
	} else {
		_g_free0 (_host);
	}
	if (port) {
		*port = _port;
	} else {
		_g_free0 (_port);
	}
}


gchar* daemon_helpers_typehelper_IndentString (const gchar* text, gint count) {
	gchar* result = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** parts;
	gint parts_length1;
	gint _parts_size_;
	gchar* _tmp2_ = NULL;
	gchar* prefix;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (text != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit (text, "\n", 0);
	parts = _tmp1_;
	parts_length1 = _vala_array_length (_tmp0_);
	_parts_size_ = _vala_array_length (_tmp0_);
	_tmp2_ = g_strnfill ((gsize) count, '\t');
	prefix = _tmp2_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gchar* _tmp4_;
				gchar* _tmp5_;
				if (!_tmp3_) {
					i++;
				}
				_tmp3_ = FALSE;
				if (!(i < parts_length1)) {
					break;
				}
				_tmp4_ = g_strconcat (prefix, parts[i], NULL);
				_tmp5_ = _tmp4_;
				_g_free0 (parts[i]);
				parts[i] = _tmp5_;
			}
		}
	}
	_tmp6_ = g_strjoinv ("\n", parts);
	result = _tmp6_;
	_g_free0 (prefix);
	parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	result = ((gchar*) self)[index];
	return result;
}


gboolean daemon_helpers_typehelper_IsNumeric (const gchar* text) {
	gboolean result = FALSE;
	g_return_val_if_fail (text != NULL, FALSE);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp1_;
				gchar _tmp2_;
				gboolean _tmp3_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				_tmp1_ = strlen (text);
				if (!(i < _tmp1_)) {
					break;
				}
				_tmp2_ = string_get (text, (glong) i);
				_tmp3_ = g_ascii_isalnum (_tmp2_);
				if (!_tmp3_) {
					result = FALSE;
					return result;
				}
			}
		}
	}
	result = TRUE;
	return result;
}


DaemonHelpersTypeHelper* daemon_helpers_typehelper_construct (GType object_type) {
	DaemonHelpersTypeHelper * self = NULL;
	self = (DaemonHelpersTypeHelper*) g_object_new (object_type, NULL);
	return self;
}


DaemonHelpersTypeHelper* daemon_helpers_typehelper_new (void) {
	return daemon_helpers_typehelper_construct (DAEMON_HELPERS_TYPE_TYPEHELPER);
}


static void daemon_helpers_typehelper_class_init (DaemonHelpersTypeHelperClass * klass) {
	daemon_helpers_typehelper_parent_class = g_type_class_peek_parent (klass);
}


static void daemon_helpers_typehelper_instance_init (DaemonHelpersTypeHelper * self) {
}


GType daemon_helpers_typehelper_get_type (void) {
	static volatile gsize daemon_helpers_typehelper_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_helpers_typehelper_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DaemonHelpersTypeHelperClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) daemon_helpers_typehelper_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DaemonHelpersTypeHelper), 0, (GInstanceInitFunc) daemon_helpers_typehelper_instance_init, NULL };
		GType daemon_helpers_typehelper_type_id;
		daemon_helpers_typehelper_type_id = g_type_register_static (G_TYPE_OBJECT, "DaemonHelpersTypeHelper", &g_define_type_info, 0);
		g_once_init_leave (&daemon_helpers_typehelper_type_id__volatile, daemon_helpers_typehelper_type_id);
	}
	return daemon_helpers_typehelper_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



