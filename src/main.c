/* main.c generated by valac 0.12.0, the Vala compiler
 * generated from main.vala, do not modify */

/*SemesterLeistung - An IRC Daemon
* Copyright (C) 2011  Simon Baumer
* 
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gio/gio.h>
#include <signal.h>
#include <libdaemon/daemon.h>


#define DAEMON_TYPE_MAIN (daemon_main_get_type ())
#define DAEMON_MAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_TYPE_MAIN, DaemonMain))
#define DAEMON_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_TYPE_MAIN, DaemonMainClass))
#define DAEMON_IS_MAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_TYPE_MAIN))
#define DAEMON_IS_MAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_TYPE_MAIN))
#define DAEMON_MAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_TYPE_MAIN, DaemonMainClass))

typedef struct _DaemonMain DaemonMain;
typedef struct _DaemonMainClass DaemonMainClass;
typedef struct _DaemonMainPrivate DaemonMainPrivate;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define DAEMON_TYPE_CONSOLE_COLORS (daemon_console_colors_get_type ())

#define DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE (daemon_configuration_configuration_file_get_type ())
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, DaemonConfigurationConfigurationFile))
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, DaemonConfigurationConfigurationFileClass))
#define DAEMON_CONFIGURATION_IS_CONFIGURATION_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE))
#define DAEMON_CONFIGURATION_IS_CONFIGURATION_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE))
#define DAEMON_CONFIGURATION_CONFIGURATION_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_CONFIGURATION_TYPE_CONFIGURATION_FILE, DaemonConfigurationConfigurationFileClass))

typedef struct _DaemonConfigurationConfigurationFile DaemonConfigurationConfigurationFile;
typedef struct _DaemonConfigurationConfigurationFileClass DaemonConfigurationConfigurationFileClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define DAEMON_HELPERS_TYPE_LIST_HELPER (daemon_helpers_list_helper_get_type ())
#define DAEMON_HELPERS_LIST_HELPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_HELPERS_TYPE_LIST_HELPER, DaemonHelpersListHelper))
#define DAEMON_HELPERS_LIST_HELPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_HELPERS_TYPE_LIST_HELPER, DaemonHelpersListHelperClass))
#define DAEMON_HELPERS_IS_LIST_HELPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_HELPERS_TYPE_LIST_HELPER))
#define DAEMON_HELPERS_IS_LIST_HELPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_HELPERS_TYPE_LIST_HELPER))
#define DAEMON_HELPERS_LIST_HELPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_HELPERS_TYPE_LIST_HELPER, DaemonHelpersListHelperClass))

typedef struct _DaemonHelpersListHelper DaemonHelpersListHelper;
typedef struct _DaemonHelpersListHelperClass DaemonHelpersListHelperClass;

#define DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION (daemon_configuration_server_configuration_get_type ())
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfiguration))
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfigurationClass))
#define DAEMON_CONFIGURATION_IS_SERVER_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION))
#define DAEMON_CONFIGURATION_IS_SERVER_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION))
#define DAEMON_CONFIGURATION_SERVER_CONFIGURATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, DaemonConfigurationServerConfigurationClass))

typedef struct _DaemonConfigurationServerConfiguration DaemonConfigurationServerConfiguration;
typedef struct _DaemonConfigurationServerConfigurationClass DaemonConfigurationServerConfigurationClass;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

#define DAEMON_TYPE_SMTP_CONFIGURATION (daemon_smtp_configuration_get_type ())
#define DAEMON_SMTP_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfiguration))
#define DAEMON_SMTP_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfigurationClass))
#define DAEMON_IS_SMTP_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_TYPE_SMTP_CONFIGURATION))
#define DAEMON_IS_SMTP_CONFIGURATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_TYPE_SMTP_CONFIGURATION))
#define DAEMON_SMTP_CONFIGURATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_TYPE_SMTP_CONFIGURATION, DaemonSmtpConfigurationClass))

typedef struct _DaemonSmtpConfiguration DaemonSmtpConfiguration;
typedef struct _DaemonSmtpConfigurationClass DaemonSmtpConfigurationClass;

#define DAEMON_DATA_TYPE_IDATA_ACCESS (daemon_data_idata_access_get_type ())
#define DAEMON_DATA_IDATA_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_DATA_TYPE_IDATA_ACCESS, DaemonDataIDataAccess))
#define DAEMON_DATA_IS_IDATA_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_DATA_TYPE_IDATA_ACCESS))
#define DAEMON_DATA_IDATA_ACCESS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), DAEMON_DATA_TYPE_IDATA_ACCESS, DaemonDataIDataAccessIface))

typedef struct _DaemonDataIDataAccess DaemonDataIDataAccess;
typedef struct _DaemonDataIDataAccessIface DaemonDataIDataAccessIface;

#define DAEMON_EVENTS_TYPE_LOG_EVENT (daemon_events_log_event_get_type ())
#define DAEMON_EVENTS_LOG_EVENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_EVENTS_TYPE_LOG_EVENT, DaemonEventsLogEvent))
#define DAEMON_EVENTS_LOG_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_EVENTS_TYPE_LOG_EVENT, DaemonEventsLogEventClass))
#define DAEMON_EVENTS_IS_LOG_EVENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_EVENTS_TYPE_LOG_EVENT))
#define DAEMON_EVENTS_IS_LOG_EVENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_EVENTS_TYPE_LOG_EVENT))
#define DAEMON_EVENTS_LOG_EVENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_EVENTS_TYPE_LOG_EVENT, DaemonEventsLogEventClass))

typedef struct _DaemonEventsLogEvent DaemonEventsLogEvent;
typedef struct _DaemonEventsLogEventClass DaemonEventsLogEventClass;

#define DAEMON_IRC_TYPE_IRC_CONNECTION (daemon_irc_irc_connection_get_type ())
#define DAEMON_IRC_IRC_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DAEMON_IRC_TYPE_IRC_CONNECTION, DaemonIRCIRCConnection))
#define DAEMON_IRC_IRC_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DAEMON_IRC_TYPE_IRC_CONNECTION, DaemonIRCIRCConnectionClass))
#define DAEMON_IRC_IS_IRC_CONNECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DAEMON_IRC_TYPE_IRC_CONNECTION))
#define DAEMON_IRC_IS_IRC_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DAEMON_IRC_TYPE_IRC_CONNECTION))
#define DAEMON_IRC_IRC_CONNECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DAEMON_IRC_TYPE_IRC_CONNECTION, DaemonIRCIRCConnectionClass))

typedef struct _DaemonIRCIRCConnection DaemonIRCIRCConnection;
typedef struct _DaemonIRCIRCConnectionClass DaemonIRCIRCConnectionClass;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))

struct _DaemonMain {
	GObject parent_instance;
	DaemonMainPrivate * priv;
};

struct _DaemonMainClass {
	GObjectClass parent_class;
};

typedef enum  {
	DAEMON_CONSOLE_COLORS_Red = 31,
	DAEMON_CONSOLE_COLORS_Green = 32,
	DAEMON_CONSOLE_COLORS_Yellow = 33,
	DAEMON_CONSOLE_COLORS_Blue = 34,
	DAEMON_CONSOLE_COLORS_Purple = 35,
	DAEMON_CONSOLE_COLORS_Cyan = 36,
	DAEMON_CONSOLE_COLORS_White = 37
} DaemonConsoleColors;

typedef enum  {
	DAEMON_CONFIGURATION_CONFIGURATION_ERROR_Invalid
} DaemonConfigurationConfigurationError;
#define DAEMON_CONFIGURATION_CONFIGURATION_ERROR daemon_configuration_configuration_error_quark ()
typedef enum  {
	DAEMON_SMTP_ERROR_InvalidConfiguration
} DaemonSmtpError;
#define DAEMON_SMTP_ERROR daemon_smtp_error_quark ()
typedef enum  {
	DAEMON_DATA_DATA_ACCESS_ERROR_OpenFailed,
	DAEMON_DATA_DATA_ACCESS_ERROR_WriteError,
	DAEMON_DATA_DATA_ACCESS_ERROR_ReadError
} DaemonDataDataAccessError;
#define DAEMON_DATA_DATA_ACCESS_ERROR daemon_data_data_access_error_quark ()
struct _DaemonDataIDataAccessIface {
	GTypeInterface parent_iface;
	void (*Log) (DaemonDataIDataAccess* self, DaemonEventsLogEvent* event, GError** error);
	GDateTime* (*UserLastSeen) (DaemonDataIDataAccess* self, const gchar* username, const gchar* channel, const gchar* server, GError** error);
	GList* (*GetLog) (DaemonDataIDataAccess* self, const gchar* channel, const gchar* server, GError** error);
	void (*Init) (DaemonDataIDataAccess* self, const gchar* logPath, GError** error);
};

typedef enum  {
	DAEMON_PLUGIN_ERROR_LibraryError
} DaemonPluginError;
#define DAEMON_PLUGIN_ERROR daemon_plugin_error_quark ()
typedef enum  {
	DAEMON_IRC_IRC_ERROR_InvalidHost,
	DAEMON_IRC_IRC_ERROR_DNSError
} DaemonIRCIRCError;
#define DAEMON_IRC_IRC_ERROR daemon_irc_irc_error_quark ()

static gpointer daemon_main_parent_class = NULL;
extern gchar* daemon_main_LogLibrary;
gchar* daemon_main_LogLibrary = NULL;
extern gchar* daemon_main_LogFile;
gchar* daemon_main_LogFile = NULL;
extern gchar* daemon_main_ConfigFile;
gchar* daemon_main_ConfigFile = NULL;
extern gboolean daemon_main_DisableDaemon;
gboolean daemon_main_DisableDaemon = FALSE;
extern gchar** daemon_main_Servers;
gchar** daemon_main_Servers = NULL;
extern gchar* daemon_main_Nicknames;
gchar* daemon_main_Nicknames = NULL;
extern gboolean daemon_main_IgnoreConfig;
gboolean daemon_main_IgnoreConfig = FALSE;
extern gboolean daemon_main_OverrideValues;
gboolean daemon_main_OverrideValues = FALSE;
extern gchar* daemon_main_RealName;
gchar* daemon_main_RealName = NULL;
extern gchar* daemon_main_Host;
gchar* daemon_main_Host = NULL;
extern gchar* daemon_main_Username;
gchar* daemon_main_Username = NULL;
extern gchar* daemon_main_Smtp;
gchar* daemon_main_Smtp = NULL;

GType daemon_main_get_type (void) G_GNUC_CONST;
enum  {
	DAEMON_MAIN_DUMMY_PROPERTY
};
static gint daemon_main_main (gchar** args, int args_length1);
GType daemon_console_colors_get_type (void) G_GNUC_CONST;
void daemon_global_log_ColorMessage (DaemonConsoleColors color, const gchar* format, ...);
GType daemon_configuration_configuration_file_get_type (void) G_GNUC_CONST;
void daemon_global_log_Error (const gchar* format, ...);
void daemon_global_log_Warning (const gchar* format, ...);
GQuark daemon_configuration_configuration_error_quark (void);
DaemonConfigurationConfigurationFile* daemon_configuration_configuration_file_Load (const gchar* filename, GError** error);
gchar* daemon_configuration_configuration_file_ToString (DaemonConfigurationConfigurationFile* self);
const gchar* daemon_configuration_configuration_file_get_LogLibrary (DaemonConfigurationConfigurationFile* self);
const gchar* daemon_configuration_configuration_file_get_LogFile (DaemonConfigurationConfigurationFile* self);
gboolean daemon_configuration_configuration_file_get_DisableDaemon (DaemonConfigurationConfigurationFile* self);
gchar** daemon_configuration_configuration_file_get_Nicknames (DaemonConfigurationConfigurationFile* self, int* result_length1);
static gchar** _vala_array_dup1 (gchar** self, int length);
static gchar** _vala_array_dup2 (gchar** self, int length);
DaemonHelpersListHelper* daemon_helpers_list_helper_new (GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func);
DaemonHelpersListHelper* daemon_helpers_list_helper_construct (GType object_type, GType t_type, GBoxedCopyFunc t_dup_func, GDestroyNotify t_destroy_func);
GType daemon_helpers_list_helper_get_type (void) G_GNUC_CONST;
gpointer* daemon_helpers_list_helper_AppendArrays (DaemonHelpersListHelper* self, gpointer* first, int first_length1, gpointer* second, int second_length1, int* result_length1);
GType daemon_configuration_server_configuration_get_type (void) G_GNUC_CONST;
DaemonConfigurationServerConfiguration** daemon_configuration_configuration_file_get_Servers (DaemonConfigurationConfigurationFile* self, int* result_length1);
static DaemonConfigurationServerConfiguration** _vala_array_dup3 (DaemonConfigurationServerConfiguration** self, int length);
DaemonConfigurationServerConfiguration* daemon_configuration_server_configuration_Parse (const gchar* input, GError** error);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
gpointer* daemon_helpers_list_helper_CopyList (DaemonHelpersListHelper* self, GList* list, int* result_length1);
gpointer* daemon_helpers_list_helper_AppendList (DaemonHelpersListHelper* self, gpointer* first, int first_length1, GList* second, int* result_length1);
const gchar* daemon_configuration_configuration_file_get_RealName (DaemonConfigurationConfigurationFile* self);
void daemon_irc_irc_connection_set_RealName (const gchar* value);
void daemon_irc_irc_connection_set_Nicknames (gchar** value, int value_length1);
const gchar* daemon_configuration_configuration_file_get_Host (DaemonConfigurationConfigurationFile* self);
void daemon_irc_irc_connection_set_Hostname (const gchar* value);
const gchar* daemon_configuration_configuration_file_get_Username (DaemonConfigurationConfigurationFile* self);
void daemon_irc_irc_connection_set_Username (const gchar* value);
gchar* daemon_configuration_server_configuration_ToString (DaemonConfigurationServerConfiguration* self);
GType daemon_smtp_configuration_get_type (void) G_GNUC_CONST;
GQuark daemon_smtp_error_quark (void);
DaemonSmtpConfiguration* daemon_smtp_configuration_Parse (const gchar* input, GError** error);
DaemonSmtpConfiguration* daemon_configuration_configuration_file_get_Smtp (DaemonConfigurationConfigurationFile* self);
void daemon_email_sender_set_Configuration (DaemonSmtpConfiguration* value);
gchar* daemon_smtp_configuration_ToString (DaemonSmtpConfiguration* self);
GType daemon_events_log_event_get_type (void) G_GNUC_CONST;
GQuark daemon_data_data_access_error_quark (void);
GType daemon_data_idata_access_get_type (void) G_GNUC_CONST;
GQuark daemon_plugin_error_quark (void);
DaemonDataIDataAccess* daemon_plugin_manager_InitDataAccess (const gchar* pluginPath, const gchar* logPath, GError** error);
GType daemon_irc_irc_connection_get_type (void) G_GNUC_CONST;
GQuark daemon_irc_irc_error_quark (void);
DaemonIRCIRCConnection* daemon_irc_irc_connection_new (DaemonConfigurationServerConfiguration* configuration, GError** error);
DaemonIRCIRCConnection* daemon_irc_irc_connection_construct (GType object_type, DaemonConfigurationServerConfiguration* configuration, GError** error);
DaemonMain* daemon_main_new (void);
DaemonMain* daemon_main_construct (GType object_type);
static void daemon_main_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const GOptionEntry DAEMON_MAIN__options[13] = {{"logger", 'l', 0, G_OPTION_ARG_FILENAME, &daemon_main_LogLibrary, "Specifies which Log Library is going to be used. Defaults to the build" \
"-in Sqlite3 Library.", NULL}, {"logfile", 'f', 0, G_OPTION_ARG_FILENAME, &daemon_main_LogFile, "Path to the Log File.", NULL}, {"config", 'c', 0, G_OPTION_ARG_FILENAME, &daemon_main_ConfigFile, "Path to the configuration file.", NULL}, {"disable-daemon", 'D', 0, G_OPTION_ARG_NONE, &daemon_main_DisableDaemon, "Disable the Daemon functionality.", NULL}, {"servers", 's', 0, G_OPTION_ARG_STRING_ARRAY, &daemon_main_Servers, "Specify the Servers and Channels to use. Use format: 'host(:port)/chan" \
"nel{,channel}'", NULL}, {"ignore-config", 'i', 0, G_OPTION_ARG_NONE, &daemon_main_IgnoreConfig, "Ignore all settings from the configuration file.", NULL}, {"override-config", 'o', 0, G_OPTION_ARG_NONE, &daemon_main_OverrideValues, "Override all Configuration options. Otherwise appends Servers and Nick" \
"names.", NULL}, {"nick", 'n', 0, G_OPTION_ARG_STRING, &daemon_main_Nicknames, "The Nicknames used by the bot. Comma-Separated.", NULL}, {"real-name", 'r', 0, G_OPTION_ARG_STRING, &daemon_main_RealName, "The \"Real name\" sent to the IRC Servers.", NULL}, {"host", 'h', 0, G_OPTION_ARG_STRING, &daemon_main_Host, "Override the hostname sent to the IRC Servers.", NULL}, {"username", 'u', 0, G_OPTION_ARG_STRING, &daemon_main_Username, "Set the username sent to the IRC Servers.", NULL}, {"smtp", 's', 0, G_OPTION_ARG_STRING, &daemon_main_Smtp, "Set the smtp configuration using the format: 'sender/host(:port)'", NULL}, {NULL}};

static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static DaemonConfigurationServerConfiguration** _vala_array_dup3 (DaemonConfigurationServerConfiguration** self, int length) {
	DaemonConfigurationServerConfiguration** result;
	int i;
	result = g_new0 (DaemonConfigurationServerConfiguration*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = _g_object_ref0 (self[i]);
	}
	return result;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gint daemon_main_main (gchar** args, int args_length1) {
	gint result = 0;
	GOptionContext* _tmp0_ = NULL;
	GOptionContext* context;
	DaemonConfigurationConfigurationFile* configuration;
	gchar* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp27_;
	gchar** _tmp28_ = NULL;
	gchar** nicknames;
	gint nicknames_length1;
	gint _nicknames_size_;
	gboolean _tmp33_ = FALSE;
	DaemonConfigurationServerConfiguration** _tmp42_ = NULL;
	DaemonConfigurationServerConfiguration** servers;
	gint servers_length1;
	gint _servers_size_;
	gboolean _tmp47_ = FALSE;
	gboolean _tmp57_ = FALSE;
	gboolean _tmp60_ = FALSE;
	GString* _tmp62_ = NULL;
	GString* nicknameBuilder;
	gchar** _tmp64_;
	gchar* _tmp65_;
	gchar* host;
	gboolean _tmp66_ = FALSE;
	gboolean _tmp69_ = FALSE;
	gchar* _tmp71_;
	gchar* _tmp72_;
	gchar* _tmp74_;
	gchar* _tmp75_;
	gchar* username;
	gboolean _tmp76_ = FALSE;
	gboolean _tmp79_ = FALSE;
	DaemonSmtpConfiguration* smtpConfiguration;
	gchar* _tmp88_ = NULL;
	gchar* _tmp89_;
	DaemonDataIDataAccess* _tmp90_ = NULL;
	DaemonDataIDataAccess* _tmp91_;
	DaemonIRCIRCConnection** _tmp93_ = NULL;
	DaemonIRCIRCConnection** connections;
	gint connections_length1;
	gint _connections_size_;
	GMainLoop* _tmp98_ = NULL;
	GMainLoop* loop;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_option_context_new ("");
	context = _tmp0_;
	g_option_context_set_help_enabled (context, TRUE);
	g_option_context_add_main_entries (context, DAEMON_MAIN__options, NULL);
	g_option_context_parse (context, &args_length1, &args, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (context);
		goto __catch0_g_error;
	}
	_g_option_context_free0 (context);
	goto __finally0;
	__catch0_g_error:
	{
		GError * _error_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stderr, "Error: %s\n", _error_->message);
		fprintf (stderr, "Run '%s --help' to see a full list of available options\n", args[0]);
		result = 1;
		_g_error_free0 (_error_);
		return result;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Blue, "Initializing the Application");
	configuration = NULL;
	if (daemon_main_IgnoreConfig) {
		if (daemon_main_OverrideValues) {
			daemon_global_log_Error ("Cannot override and ignore Configuration");
			result = 1;
			_g_object_unref0 (configuration);
			return result;
		}
		daemon_global_log_Warning ("Ignoring Configuration File");
	} else {
		gchar* _tmp1_;
		gchar* _tmp2_;
		gchar* _tmp4_;
		GFile* _tmp5_ = NULL;
		GFile* configFile;
		gboolean _tmp6_;
		_tmp1_ = g_strdup (daemon_main_ConfigFile);
		_tmp2_ = _tmp1_;
		if (_tmp2_ == NULL) {
			gchar* _tmp3_;
			_tmp3_ = g_strdup ("/etc/daemon/config.xml");
			_g_free0 (_tmp2_);
			_tmp2_ = _tmp3_;
		}
		_tmp4_ = g_strdup (_tmp2_);
		_g_free0 (daemon_main_ConfigFile);
		daemon_main_ConfigFile = _tmp4_;
		_tmp5_ = g_file_new_for_path (daemon_main_ConfigFile);
		configFile = _tmp5_;
		_tmp6_ = g_file_query_exists (configFile, NULL);
		if (_tmp6_) {
			DaemonConfigurationConfigurationFile* _tmp7_ = NULL;
			DaemonConfigurationConfigurationFile* _tmp8_;
			gchar* _tmp9_ = NULL;
			gchar* _tmp10_;
			daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using Configuration File: %s", daemon_main_ConfigFile);
			_tmp7_ = daemon_configuration_configuration_file_Load (daemon_main_ConfigFile, &_inner_error_);
			_tmp8_ = _tmp7_;
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
					goto __catch1_daemon_configuration_configuration_error;
				}
				_g_object_unref0 (configFile);
				_g_free0 (_tmp2_);
				_g_object_unref0 (configuration);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
			_g_object_unref0 (configuration);
			configuration = _tmp8_;
			daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Successfully loaded Configuration File, settings:");
			_tmp9_ = daemon_configuration_configuration_file_ToString (configuration);
			_tmp10_ = _tmp9_;
			daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Blue, "%s", _tmp10_);
			_g_free0 (_tmp10_);
			goto __finally1;
			__catch1_daemon_configuration_configuration_error:
			{
				GError * _error_;
				_error_ = _inner_error_;
				_inner_error_ = NULL;
				daemon_global_log_Error ("Loading Configuration File %s failed: %s", daemon_main_ConfigFile, _error_->message);
				result = 1;
				_g_error_free0 (_error_);
				_g_object_unref0 (configFile);
				_g_free0 (_tmp2_);
				_g_object_unref0 (configuration);
				return result;
			}
			__finally1:
			if (_inner_error_ != NULL) {
				_g_object_unref0 (configFile);
				_g_free0 (_tmp2_);
				_g_object_unref0 (configuration);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
		} else {
			daemon_global_log_Warning ("Could not open Configuration File: %s", daemon_main_ConfigFile);
		}
		_g_object_unref0 (configFile);
		_g_free0 (_tmp2_);
	}
	if (daemon_main_OverrideValues) {
		daemon_global_log_Warning ("Overriding Configuration");
	}
	if (configuration != NULL) {
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		gchar* _tmp17_;
		gchar* _tmp20_;
		gboolean _tmp21_ = FALSE;
		_tmp11_ = g_strdup (daemon_main_LogLibrary);
		_tmp12_ = _tmp11_;
		if (_tmp12_ == NULL) {
			const gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			_tmp13_ = daemon_configuration_configuration_file_get_LogLibrary (configuration);
			_tmp14_ = g_strdup (_tmp13_);
			_g_free0 (_tmp12_);
			_tmp12_ = _tmp14_;
		}
		_tmp15_ = g_strdup (_tmp12_);
		_g_free0 (daemon_main_LogLibrary);
		daemon_main_LogLibrary = _tmp15_;
		_tmp16_ = g_strdup (daemon_main_LogFile);
		_tmp17_ = _tmp16_;
		if (_tmp17_ == NULL) {
			const gchar* _tmp18_ = NULL;
			gchar* _tmp19_;
			_tmp18_ = daemon_configuration_configuration_file_get_LogFile (configuration);
			_tmp19_ = g_strdup (_tmp18_);
			_g_free0 (_tmp17_);
			_tmp17_ = _tmp19_;
		}
		_tmp20_ = g_strdup (_tmp17_);
		_g_free0 (daemon_main_LogFile);
		daemon_main_LogFile = _tmp20_;
		if (daemon_main_DisableDaemon) {
			_tmp21_ = TRUE;
		} else {
			gboolean _tmp22_;
			_tmp22_ = daemon_configuration_configuration_file_get_DisableDaemon (configuration);
			_tmp21_ = _tmp22_;
		}
		daemon_main_DisableDaemon = _tmp21_;
		_g_free0 (_tmp17_);
		_g_free0 (_tmp12_);
	}
	if (daemon_main_LogLibrary == NULL) {
		daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using default log library");
	} else {
		daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using log library located at: %s", daemon_main_LogLibrary);
	}
	_tmp23_ = g_strdup (daemon_main_LogFile);
	_tmp24_ = _tmp23_;
	if (_tmp24_ == NULL) {
		const gchar* _tmp25_ = NULL;
		gchar* _tmp26_;
		_tmp25_ = g_get_home_dir ();
		_tmp26_ = g_strconcat (_tmp25_, "/data.db", NULL);
		_g_free0 (_tmp24_);
		_tmp24_ = _tmp26_;
	}
	_tmp27_ = g_strdup (_tmp24_);
	_g_free0 (daemon_main_LogFile);
	daemon_main_LogFile = _tmp27_;
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using Log File at %s", daemon_main_LogFile);
	_tmp28_ = g_new0 (gchar*, 0 + 1);
	nicknames = _tmp28_;
	nicknames_length1 = 0;
	_nicknames_size_ = 0;
	if (configuration != NULL) {
		gchar** _tmp29_ = NULL;
		gint _tmp30_;
		gchar** _tmp31_;
		gchar** _tmp32_;
		_tmp29_ = daemon_configuration_configuration_file_get_Nicknames (configuration, &_tmp30_);
		_tmp31_ = (_tmp32_ = _tmp29_, (_tmp32_ == NULL) ? ((gpointer) _tmp32_) : _vala_array_dup1 (_tmp32_, _tmp30_));
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		nicknames = _tmp31_;
		nicknames_length1 = _tmp30_;
		_nicknames_size_ = _tmp30_;
	}
	if (daemon_main_Nicknames != NULL) {
		gint _tmp34_;
		_tmp34_ = strlen (daemon_main_Nicknames);
		_tmp33_ = _tmp34_ > 0;
	} else {
		_tmp33_ = FALSE;
	}
	if (_tmp33_) {
		gchar** _tmp35_;
		gchar** _tmp36_ = NULL;
		gchar** newNicknames;
		gint newNicknames_length1;
		gint _newNicknames_size_;
		_tmp36_ = _tmp35_ = g_strsplit (daemon_main_Nicknames, ",", 0);
		newNicknames = _tmp36_;
		newNicknames_length1 = _vala_array_length (_tmp35_);
		_newNicknames_size_ = _vala_array_length (_tmp35_);
		if (daemon_main_OverrideValues) {
			gchar** _tmp37_;
			gchar** _tmp38_;
			_tmp37_ = (_tmp38_ = newNicknames, (_tmp38_ == NULL) ? ((gpointer) _tmp38_) : _vala_array_dup2 (_tmp38_, newNicknames_length1));
			nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
			nicknames = _tmp37_;
			nicknames_length1 = newNicknames_length1;
			_nicknames_size_ = newNicknames_length1;
		} else {
			DaemonHelpersListHelper* _tmp39_ = NULL;
			DaemonHelpersListHelper* helper;
			gint _tmp40_;
			gpointer* _tmp41_ = NULL;
			_tmp39_ = daemon_helpers_list_helper_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free);
			helper = _tmp39_;
			_tmp41_ = daemon_helpers_list_helper_AppendArrays (helper, nicknames, nicknames_length1, newNicknames, newNicknames_length1, &_tmp40_);
			nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
			nicknames = _tmp41_;
			nicknames_length1 = _tmp40_;
			_nicknames_size_ = _tmp40_;
			_g_object_unref0 (helper);
		}
		daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using these nicknames in this order:");
		newNicknames = (_vala_array_free (newNicknames, newNicknames_length1, (GDestroyNotify) g_free), NULL);
	}
	if (nicknames_length1 == 0) {
		daemon_global_log_Error ("No nicknames specified");
		result = 1;
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	_tmp42_ = g_new0 (DaemonConfigurationServerConfiguration*, 0 + 1);
	servers = _tmp42_;
	servers_length1 = 0;
	_servers_size_ = 0;
	if (configuration != NULL) {
		DaemonConfigurationServerConfiguration** _tmp43_ = NULL;
		gint _tmp44_;
		DaemonConfigurationServerConfiguration** _tmp45_;
		DaemonConfigurationServerConfiguration** _tmp46_;
		_tmp43_ = daemon_configuration_configuration_file_get_Servers (configuration, &_tmp44_);
		_tmp45_ = (_tmp46_ = _tmp43_, (_tmp46_ == NULL) ? ((gpointer) _tmp46_) : _vala_array_dup3 (_tmp46_, _tmp44_));
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		servers = _tmp45_;
		servers_length1 = _tmp44_;
		_servers_size_ = _tmp44_;
	}
	if (daemon_main_Servers != NULL) {
		_tmp47_ = _vala_array_length (daemon_main_Servers) != 0;
	} else {
		_tmp47_ = FALSE;
	}
	if (_tmp47_) {
		GList* serverList;
		DaemonHelpersListHelper* _tmp52_ = NULL;
		DaemonHelpersListHelper* helper;
		serverList = NULL;
		{
			gchar** current_collection;
			int current_collection_length1;
			int current_it;
			current_collection = daemon_main_Servers;
			current_collection_length1 = _vala_array_length (daemon_main_Servers);
			for (current_it = 0; current_it < _vala_array_length (daemon_main_Servers); current_it = current_it + 1) {
				gchar* _tmp48_;
				gchar* current;
				_tmp48_ = g_strdup (current_collection[current_it]);
				current = _tmp48_;
				{
					DaemonConfigurationServerConfiguration* server = NULL;
					DaemonConfigurationServerConfiguration* _tmp49_ = NULL;
					DaemonConfigurationServerConfiguration* _tmp50_;
					DaemonConfigurationServerConfiguration* _tmp51_;
					_tmp49_ = daemon_configuration_server_configuration_Parse (current, &_inner_error_);
					_tmp50_ = _tmp49_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == DAEMON_CONFIGURATION_CONFIGURATION_ERROR) {
							goto __catch2_daemon_configuration_configuration_error;
						}
						_g_object_unref0 (server);
						_g_free0 (current);
						__g_list_free__g_object_unref0_0 (serverList);
						servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
						nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (_tmp24_);
						_g_object_unref0 (configuration);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return 0;
					}
					_g_object_unref0 (server);
					server = _tmp50_;
					_tmp51_ = _g_object_ref0 (server);
					serverList = g_list_append (serverList, _tmp51_);
					goto __finally2;
					__catch2_daemon_configuration_configuration_error:
					{
						GError * _error_;
						_error_ = _inner_error_;
						_inner_error_ = NULL;
						daemon_global_log_Error ("Server configuration invalid, reason: %s", _error_->message);
						result = 1;
						_g_error_free0 (_error_);
						_g_object_unref0 (server);
						_g_free0 (current);
						__g_list_free__g_object_unref0_0 (serverList);
						servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
						nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (_tmp24_);
						_g_object_unref0 (configuration);
						return result;
					}
					__finally2:
					if (_inner_error_ != NULL) {
						_g_object_unref0 (server);
						_g_free0 (current);
						__g_list_free__g_object_unref0_0 (serverList);
						servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
						nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (_tmp24_);
						_g_object_unref0 (configuration);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return 0;
					}
					_g_object_unref0 (server);
					_g_free0 (current);
				}
			}
		}
		_tmp52_ = daemon_helpers_list_helper_new (DAEMON_CONFIGURATION_TYPE_SERVER_CONFIGURATION, (GBoxedCopyFunc) g_object_ref, g_object_unref);
		helper = _tmp52_;
		if (daemon_main_OverrideValues) {
			gint _tmp53_;
			gpointer* _tmp54_ = NULL;
			_tmp54_ = daemon_helpers_list_helper_CopyList (helper, serverList, &_tmp53_);
			servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
			servers = _tmp54_;
			servers_length1 = _tmp53_;
			_servers_size_ = _tmp53_;
		} else {
			gint _tmp55_;
			gpointer* _tmp56_ = NULL;
			_tmp56_ = daemon_helpers_list_helper_AppendList (helper, servers, servers_length1, serverList, &_tmp55_);
			servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
			servers = _tmp56_;
			servers_length1 = _tmp55_;
			_servers_size_ = _tmp55_;
		}
		_g_object_unref0 (helper);
		__g_list_free__g_object_unref0_0 (serverList);
	}
	if (servers_length1 == 0) {
		daemon_global_log_Error ("No servers specified");
		result = 1;
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	if (daemon_main_RealName == NULL) {
		_tmp57_ = configuration != NULL;
	} else {
		_tmp57_ = FALSE;
	}
	if (_tmp57_) {
		const gchar* _tmp58_ = NULL;
		gchar* _tmp59_;
		_tmp58_ = daemon_configuration_configuration_file_get_RealName (configuration);
		_tmp59_ = g_strdup (_tmp58_);
		_g_free0 (daemon_main_RealName);
		daemon_main_RealName = _tmp59_;
	}
	if (daemon_main_RealName == NULL) {
		_tmp60_ = TRUE;
	} else {
		gint _tmp61_;
		_tmp61_ = strlen (daemon_main_RealName);
		_tmp60_ = _tmp61_ == 0;
	}
	if (_tmp60_) {
		daemon_global_log_Error ("No \"Real Name\" specified");
		result = 1;
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using \"Real Name\": '%s'", daemon_main_RealName);
	daemon_irc_irc_connection_set_RealName (daemon_main_RealName);
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using nicknames:");
	_tmp62_ = g_string_new ("");
	nicknameBuilder = _tmp62_;
	g_string_append (nicknameBuilder, "[\n\t");
	{
		gint i;
		i = 0;
		{
			gboolean _tmp63_;
			_tmp63_ = TRUE;
			while (TRUE) {
				if (!_tmp63_) {
					i++;
				}
				_tmp63_ = FALSE;
				if (!(i < nicknames_length1)) {
					break;
				}
				g_string_append (nicknameBuilder, nicknames[i]);
				if (i < (nicknames_length1 - 1)) {
					g_string_append (nicknameBuilder, ",\n\t");
				}
			}
		}
	}
	g_string_append (nicknameBuilder, "\n]");
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Purple, "%s", nicknameBuilder->str);
	_tmp64_ = nicknames;
	daemon_irc_irc_connection_set_Nicknames (_tmp64_, nicknames_length1);
	_tmp65_ = g_strdup (daemon_main_Host);
	host = _tmp65_;
	if (daemon_main_Host == NULL) {
		_tmp66_ = configuration != NULL;
	} else {
		_tmp66_ = FALSE;
	}
	if (_tmp66_) {
		const gchar* _tmp67_ = NULL;
		gchar* _tmp68_;
		_tmp67_ = daemon_configuration_configuration_file_get_Host (configuration);
		_tmp68_ = g_strdup (_tmp67_);
		_g_free0 (host);
		host = _tmp68_;
	}
	if (host != NULL) {
		gint _tmp70_;
		_tmp70_ = strlen (host);
		_tmp69_ = _tmp70_ == 0;
	} else {
		_tmp69_ = FALSE;
	}
	if (_tmp69_) {
		daemon_global_log_Error ("Invalid hostname");
		result = 1;
		_g_free0 (host);
		_g_string_free0 (nicknameBuilder);
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	_tmp71_ = g_strdup (host);
	_tmp72_ = _tmp71_;
	if (_tmp72_ == NULL) {
		gchar* _tmp73_;
		_tmp73_ = g_strdup ("none");
		_g_free0 (_tmp72_);
		_tmp72_ = _tmp73_;
	}
	_tmp74_ = g_strdup (_tmp72_);
	_g_free0 (host);
	host = _tmp74_;
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Sending host: %s", host);
	daemon_irc_irc_connection_set_Hostname (host);
	_tmp75_ = g_strdup (daemon_main_Username);
	username = _tmp75_;
	if (daemon_main_Username == NULL) {
		_tmp76_ = configuration != NULL;
	} else {
		_tmp76_ = FALSE;
	}
	if (_tmp76_) {
		const gchar* _tmp77_ = NULL;
		gchar* _tmp78_;
		_tmp77_ = daemon_configuration_configuration_file_get_Username (configuration);
		_tmp78_ = g_strdup (_tmp77_);
		_g_free0 (username);
		username = _tmp78_;
	}
	if (username == NULL) {
		_tmp79_ = TRUE;
	} else {
		gint _tmp80_;
		_tmp80_ = strlen (username);
		_tmp79_ = _tmp80_ == 0;
	}
	if (_tmp79_) {
		daemon_global_log_Error ("No Username set.");
		result = 1;
		_g_free0 (username);
		_g_free0 (_tmp72_);
		_g_free0 (host);
		_g_string_free0 (nicknameBuilder);
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Sending Username: %s", username);
	daemon_irc_irc_connection_set_Username (username);
	{
		DaemonConfigurationServerConfiguration** current_collection;
		int current_collection_length1;
		int current_it;
		current_collection = servers;
		current_collection_length1 = servers_length1;
		for (current_it = 0; current_it < servers_length1; current_it = current_it + 1) {
			DaemonConfigurationServerConfiguration* _tmp81_;
			DaemonConfigurationServerConfiguration* current;
			_tmp81_ = _g_object_ref0 (current_collection[current_it]);
			current = _tmp81_;
			{
				gchar* _tmp82_ = NULL;
				gchar* _tmp83_;
				daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using Server:");
				_tmp82_ = daemon_configuration_server_configuration_ToString (current);
				_tmp83_ = _tmp82_;
				daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Purple, "%s", _tmp83_);
				_g_free0 (_tmp83_);
				_g_object_unref0 (current);
			}
		}
	}
	smtpConfiguration = NULL;
	if (daemon_main_Smtp != NULL) {
		DaemonSmtpConfiguration* _tmp84_ = NULL;
		DaemonSmtpConfiguration* _tmp85_;
		_tmp84_ = daemon_smtp_configuration_Parse (daemon_main_Smtp, &_inner_error_);
		_tmp85_ = _tmp84_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == DAEMON_SMTP_ERROR) {
				goto __catch3_daemon_smtp_error;
			}
			_g_object_unref0 (smtpConfiguration);
			_g_free0 (username);
			_g_free0 (_tmp72_);
			_g_free0 (host);
			_g_string_free0 (nicknameBuilder);
			servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
			nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (_tmp24_);
			_g_object_unref0 (configuration);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		_g_object_unref0 (smtpConfiguration);
		smtpConfiguration = _tmp85_;
		goto __finally3;
		__catch3_daemon_smtp_error:
		{
			GError * _error_;
			_error_ = _inner_error_;
			_inner_error_ = NULL;
			daemon_global_log_Error ("Could not parse SMTP Configuration: %s", _error_->message);
			_g_error_free0 (_error_);
		}
		__finally3:
		if (_inner_error_ != NULL) {
			_g_object_unref0 (smtpConfiguration);
			_g_free0 (username);
			_g_free0 (_tmp72_);
			_g_free0 (host);
			_g_string_free0 (nicknameBuilder);
			servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
			nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (_tmp24_);
			_g_object_unref0 (configuration);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
	} else {
		if (configuration != NULL) {
			DaemonSmtpConfiguration* _tmp86_ = NULL;
			DaemonSmtpConfiguration* _tmp87_;
			_tmp86_ = daemon_configuration_configuration_file_get_Smtp (configuration);
			_tmp87_ = _g_object_ref0 (_tmp86_);
			_g_object_unref0 (smtpConfiguration);
			smtpConfiguration = _tmp87_;
		}
	}
	if (smtpConfiguration == NULL) {
		daemon_global_log_Error ("No SMTP configuration set");
		result = 1;
		_g_object_unref0 (smtpConfiguration);
		_g_free0 (username);
		_g_free0 (_tmp72_);
		_g_free0 (host);
		_g_string_free0 (nicknameBuilder);
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	daemon_email_sender_set_Configuration (smtpConfiguration);
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Using SMTP Configuration:");
	_tmp88_ = daemon_smtp_configuration_ToString (smtpConfiguration);
	_tmp89_ = _tmp88_;
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Purple, "%s", _tmp89_);
	_g_free0 (_tmp89_);
	if (daemon_main_DisableDaemon) {
		daemon_global_log_Warning ("Not running as Daemon");
	} else {
		daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Blue, "Running as Daemon");
	}
	_tmp90_ = daemon_plugin_manager_InitDataAccess (daemon_main_LogLibrary, daemon_main_LogFile, &_inner_error_);
	_tmp91_ = _tmp90_;
	_g_object_unref0 (_tmp91_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == DAEMON_PLUGIN_ERROR) {
			goto __catch4_daemon_plugin_error;
		}
		if (_inner_error_->domain == DAEMON_DATA_DATA_ACCESS_ERROR) {
			goto __catch4_daemon_data_data_access_error;
		}
		_g_object_unref0 (smtpConfiguration);
		_g_free0 (username);
		_g_free0 (_tmp72_);
		_g_free0 (host);
		_g_string_free0 (nicknameBuilder);
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	goto __finally4;
	__catch4_daemon_plugin_error:
	{
		GError * _error_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		daemon_global_log_Error ("Could not initialize Log Library: %s", _error_->message);
		result = 1;
		_g_error_free0 (_error_);
		_g_object_unref0 (smtpConfiguration);
		_g_free0 (username);
		_g_free0 (_tmp72_);
		_g_free0 (host);
		_g_string_free0 (nicknameBuilder);
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	goto __finally4;
	__catch4_daemon_data_data_access_error:
	{
		GError * _error_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		daemon_global_log_Error ("Log Library threw Exception: %s", _error_->message);
		result = 1;
		_g_error_free0 (_error_);
		_g_object_unref0 (smtpConfiguration);
		_g_free0 (username);
		_g_free0 (_tmp72_);
		_g_free0 (host);
		_g_string_free0 (nicknameBuilder);
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		return result;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (smtpConfiguration);
		_g_free0 (username);
		_g_free0 (_tmp72_);
		_g_free0 (host);
		_g_string_free0 (nicknameBuilder);
		servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
		nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp24_);
		_g_object_unref0 (configuration);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	if (!daemon_main_DisableDaemon) {
		GPid _tmp92_;
		_tmp92_ = daemon_fork ();
		if (_tmp92_ != 0) {
			result = 0;
			_g_object_unref0 (smtpConfiguration);
			_g_free0 (username);
			_g_free0 (_tmp72_);
			_g_free0 (host);
			_g_string_free0 (nicknameBuilder);
			servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
			nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
			_g_free0 (_tmp24_);
			_g_object_unref0 (configuration);
			return result;
		}
	}
	_tmp93_ = g_new0 (DaemonIRCIRCConnection*, servers_length1 + 1);
	connections = _tmp93_;
	connections_length1 = servers_length1;
	_connections_size_ = servers_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp94_;
			_tmp94_ = TRUE;
			while (TRUE) {
				DaemonIRCIRCConnection* _tmp95_ = NULL;
				DaemonIRCIRCConnection* _tmp96_;
				DaemonIRCIRCConnection* _tmp97_;
				if (!_tmp94_) {
					i++;
				}
				_tmp94_ = FALSE;
				if (!(i < servers_length1)) {
					break;
				}
				_tmp95_ = daemon_irc_irc_connection_new (servers[i], &_inner_error_);
				_tmp96_ = _tmp95_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == DAEMON_IRC_IRC_ERROR) {
						goto __catch5_daemon_irc_irc_error;
					}
					connections = (_vala_array_free (connections, connections_length1, (GDestroyNotify) g_object_unref), NULL);
					_g_object_unref0 (smtpConfiguration);
					_g_free0 (username);
					_g_free0 (_tmp72_);
					_g_free0 (host);
					_g_string_free0 (nicknameBuilder);
					servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
					nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (_tmp24_);
					_g_object_unref0 (configuration);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0;
				}
				_tmp97_ = _tmp96_;
				_g_object_unref0 (connections[i]);
				connections[i] = _tmp97_;
				goto __finally5;
				__catch5_daemon_irc_irc_error:
				{
					GError * _error_;
					_error_ = _inner_error_;
					_inner_error_ = NULL;
					daemon_global_log_Error ("%s", _error_->message);
					result = 1;
					_g_error_free0 (_error_);
					connections = (_vala_array_free (connections, connections_length1, (GDestroyNotify) g_object_unref), NULL);
					_g_object_unref0 (smtpConfiguration);
					_g_free0 (username);
					_g_free0 (_tmp72_);
					_g_free0 (host);
					_g_string_free0 (nicknameBuilder);
					servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
					nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (_tmp24_);
					_g_object_unref0 (configuration);
					return result;
				}
				__finally5:
				if (_inner_error_ != NULL) {
					connections = (_vala_array_free (connections, connections_length1, (GDestroyNotify) g_object_unref), NULL);
					_g_object_unref0 (smtpConfiguration);
					_g_free0 (username);
					_g_free0 (_tmp72_);
					_g_free0 (host);
					_g_string_free0 (nicknameBuilder);
					servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
					nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (_tmp24_);
					_g_object_unref0 (configuration);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0;
				}
			}
		}
	}
	daemon_global_log_ColorMessage (DAEMON_CONSOLE_COLORS_Green, "Application initialized");
	_tmp98_ = g_main_loop_new (NULL, FALSE);
	loop = _tmp98_;
	g_main_loop_run (loop);
	result = 0;
	_g_main_loop_unref0 (loop);
	connections = (_vala_array_free (connections, connections_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (smtpConfiguration);
	_g_free0 (username);
	_g_free0 (_tmp72_);
	_g_free0 (host);
	_g_string_free0 (nicknameBuilder);
	servers = (_vala_array_free (servers, servers_length1, (GDestroyNotify) g_object_unref), NULL);
	nicknames = (_vala_array_free (nicknames, nicknames_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (_tmp24_);
	_g_object_unref0 (configuration);
	return result;
}


int main (int argc, char ** argv) {
	g_thread_init (NULL);
	g_type_init ();
	return daemon_main_main (argv, argc);
}


DaemonMain* daemon_main_construct (GType object_type) {
	DaemonMain * self = NULL;
	self = (DaemonMain*) g_object_new (object_type, NULL);
	return self;
}


DaemonMain* daemon_main_new (void) {
	return daemon_main_construct (DAEMON_TYPE_MAIN);
}


static void daemon_main_class_init (DaemonMainClass * klass) {
	daemon_main_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = daemon_main_finalize;
}


static void daemon_main_instance_init (DaemonMain * self) {
}


static void daemon_main_finalize (GObject* obj) {
	DaemonMain * self;
	self = DAEMON_MAIN (obj);
	G_OBJECT_CLASS (daemon_main_parent_class)->finalize (obj);
}


GType daemon_main_get_type (void) {
	static volatile gsize daemon_main_type_id__volatile = 0;
	if (g_once_init_enter (&daemon_main_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DaemonMainClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) daemon_main_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DaemonMain), 0, (GInstanceInitFunc) daemon_main_instance_init, NULL };
		GType daemon_main_type_id;
		daemon_main_type_id = g_type_register_static (G_TYPE_OBJECT, "DaemonMain", &g_define_type_info, 0);
		g_once_init_leave (&daemon_main_type_id__volatile, daemon_main_type_id);
	}
	return daemon_main_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



